## 线程的示例

```rust
fn main()
{
    let v = vec![1, 2, 3];
    let handle = thread::spawn(move || {
        println!("number {:?} from thread.", v);
    });

    handle.join().unwrap();
}
```


## 并发1: 通道与消息

使用通道来进行线程间通信，在通道之间发送和接收消息。

`mpsc` 表示多个生产者，单个消费者的模式：

```rust
fn main()
{
    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move ||{
        let val = "hi from t2".to_string();
        tx1.send(val).unwrap();
        // tx1 自动 drop，通道发送端计数 -1
    });

    thread::spawn(move || {
        let vals = vec![
            "hi from t1".to_string(),
            "hello from t1".to_string(),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
        // tx 自动 drop，通道发送端计数 -1
    });

    for received in rx {
        println!("get: {}", received);
    }
    // rx 自动 drop，通道接收端关闭
}
```


## 并发2: 共享内存

通过共享内存实现线程间通信。这种方法比使用通道更危险。

`Mutex` 是一种智能指针，可以将数据用互斥量保护起来。`Mutex` 与 `RefCell` 类似，可以通过不变量进行修改。

使用 `Arc` 在线程之间分享互斥量。`Arc` 表示 atomic 的引用计数指针。它和 `Rc` 的区别在于，引用计数的改变是「原子操作」。

```rust
fn main()
{
    let counter = Arc::new(Mutex::new(0));
    let mut thread_handles = vec![];

    for _ in 0..10 {
        let counter = counter.clone();
        thread_handles.push(thread::spawn(move || {
            // 阻塞式加锁
            let mut num = counter.lock().unwrap();
            *num += 1;
            // num 自动 drop，锁释放
        }));
    }

    for handle in thread_handles {
        handle.join().unwrap();
    }

    println!("result: {}", *counter.lock().unwrap());
}
```


## 并发相关的 trait

### Send 

`Send` 这个 trait 允许在线程之间移动所有权。除了 `Rc` ，几乎所有类型都是允许 `Send` 的。（如果成员是可以 `Send` 的，那么类型自动实现 `Send` ）


### Sync

`Sync` 这个 trait 允许在线程之间引用。

### 项目组织

#### workspace

如果项目比较复杂，可以用同一个 workspace 来管理多个 package，通过 `cargo.toml` 的 `members` 字段指定。

workspace 中的 package 可以共享  Cargo.lock 和 output 文件夹。

文件结构为：

```
.
├── package1
│   ├── src 
│   └── Cargo.toml 
├── somefoler
│   ├── package2 
│   └── package3
└── Cargo.toml
```

其中，workspace 下的 Cargo.toml 文件内容为：
```toml
[workspace]
members = ["package1", "somefolder/*"]

[workspace.dependencies]
static_init = "1.0.3"
```


#### package 和 crate

可以通过 `carge new name` 创建一个 package

package 中可以包含 binary crate 和 library crate。一个 package 可以包含多个 binary crate，但是只能包含一个 library crate

默认情况下，`src/main.rs` 表示一个和 package 同名的 binary crate；`src/lib.rs` 表示和 package 同名的 library crate。

注意 `cargo` 的构建命令：

```shell
cargo build --package name --bin name
```

注：使用 cargo 进行构建时，cargo 会设置环境变量 `CARGO_MANIFEST_PACKAGE`，它等于包含 package 的 manifest 文件的文件夹。

文件结构为：（examlpes 和 src 一样，都是 rust 的默认文件夹）

```
.
├── examles
│   ├── ex1.rs
│   └── ex2
│       └── main.rs
├── src
│   ├── lib.rs
│   └── main.rs
└── Cargo.toml
```


#### module

crate 中可以包含各种 module；module 本身也可以包含子 module

module 的代码一般位于声明位置的文件夹下，或者就在当前文件定义：

```rust
// src/main.rs
pub mod mod_name;

// module.rs 的代码应该位于 src/mod_name.rs 中
```


绝对路径：以 crate 开头

- 如果位于同一个 crate 中，那么可以直接用 `crate::` 
- 如果位于 crate 之外，需要使用 crate 的名称。

相对路径：需要位于同一个 crate 中，以 module 的名称开头。可以使用 `super` 关键字，到达上一级的 module

#### privacy

子模块中的内容对于父模块是默认不可见的；父模块中的内容对于子模块是默认可见的。

如果要访问子模块中的内容，需要确保中间的模块都是 pub 的，要访问的内容也是 pub 的。

可以为结构体的字段设置 pub，不影响当前 module 的访问，只会影响父 module 对结构体的访问。

无法为 enum 的某个字段单独指定 pub 

#### use

use 可以减少路径的长度，等价于文件系统中的快捷方式。不使用 use，也可以直接用外部 module

use 只在当前 module 中有效。

使用 `as` 为 module 设置别名

```rust
use std::fmt::Result;
use std::io::Result as IoResult;
```

结合 pub 再导出，使用「软连接」的概念来理解。

```rust
// 现在外部也可以
pub use crate::xxx::xxx;    
```


一次导入多个：

```rust
// 同时引入 sdt::io 和 std::io::Write
use std::io::{self, Write};
```

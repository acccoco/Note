
宏的基础可以参考：[The Little Book of Rust Macros ](https://zjp-cn.github.io/tlborm/introduction.html)


宏的原理：

* 编译器解析源代码，生成 token，再将其组织成 token stream。然后根据 token stream 的得到最终的 AST。
* 过程式宏的输入输出都是 token stream。


过程式宏的输入是 token stream（词法分析的结果）。程序员需要将在过程式宏中完成「语法分析」，并生成新的 token stream 返回。

---


### 宏

#### 声明式宏

类似于 match 表达式匹配，它匹配的对象是代码，例如：

```rust
#[macro_export]
macro_rules! vec {
    // 将表达式存放在宏变量 x 中
    // ,* 表示零个或者多个 ,
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```


#### 过程宏

过程宏可以接受代码作为输入，输出代码。

例如 `#[dereive(XXX)]` 

过程宏是一个函数，接受 AST（抽象语法树）输入，输出 AST。

宏的部分代码如下：

```rust
fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
```


过程宏可以做下面的事情：

```rust
#[route(GET, "/")]
fn index() {}

let sql = sql!(SELECT * FROM posts WHERE id=1);
```

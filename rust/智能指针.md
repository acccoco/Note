### 智能指针

智能指针通过 struct 实现，需要时心啊 `Deref` 和 `Drop` trait


#### Box

Box 可以理解为指针。在作用域结束时，栈上和堆上的内存都会被释放。

通过 Box 可以实现递归类型的定义：链表，二叉树等

例如，cons （一种链表）的定义：

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,    // 表示结尾
}

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(3, Box::new(Nil)))));
}
```


#### Deref

引用实际上是一种指针：

```rust
let x = 5;     // x 的类型是 i32
let y = &x;    // y 的类型是 &i32
assert_eq!(5, *y);
```

实现了 `Deref` trait，就可以进行解引用运算 `*` ：

```rust
impl<T> Deref for MyBox<T> {
    type Target = T;

    // 注意，这里返回的是引用
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```


> [!info] 
> 解引用运算符 `*` ，可以将 `&T` 类型变成 `T` 类型。
> 
> 对 `Box<T>` 类型进行该运算符，实际发生的是：`*(b.deref())` 
> 
> 效果等同于 c 里面的 * 运算符




#### Deref Coercion

Deref Coercion（解引用，强制）：可以将「如 `Box` 这样的实现了 `Deref` trait 的类型」的引用，转换为另一种类型的引用。例如，将 `&String` 转换为 `&str` 。这种转换可以发生多次。

Deref Coercion 使得智能指针的引用可以表现得像普通的引用一样。

```rust
fn main()
{
    let s = String::from("hello");
    
    foo(&s);      // 将 &String 转换为了 &str
    foo(&s[..]);  // 不使用 Deref Coercion
}

fn foo(s: &str)
{
    println!("content: {}", s);
}
```


如果实现了 `DerefMut` trait，就可以得到 `&mut T` 。相应的 Deref Coercion 也会发生。


#### Drop

在离开作用域时，会发生 drop，可以通过 `Drop` trait 来指定其行为。

可以通过 `std::mem::drop` 方法来手动执行 drop。

`std::mem::drop` 是一个 move 操作，此后，智能指针就失效了。

在 ownership system 的帮助下，drop 是非常可靠的。


#### Rc

这是带有引用计数的智能指针。用于这种情况：一个值可能被多个变量拥有。

`Rc<T>` 只允许 immutable 的 borrow。

使用的一个关键是：无法在编译期得知多个拥有者中谁是最后使用数据的。

创建和分享 `Rc<T>` 的方法：

```rust

use std::rc::Rc;

fn main() {
    let a = Rc::new(123);
    let b = Rc::clone(&a);
}
```


#### RefCell

RefCell 是在 runtime 检测 ownership rules，而 Box 可以在编译期检查 ownership rules。

使用 RefCell：

- 通过 `borrow()` 创建 immutable 引用，返回的是 `Ref<T>` 
- 通过 `borrow_mut()` 创建 mutable 引用，返回 `RefMut<T>` 


RefCell 是如何实现在 runtime 检查 ownership 的：调用 `borrow` 和 `borrow_mut` 时，RefCell 内部计数会增加，以此来保证 ownership rules。

以下代码会出现 panic：

```rust
use std::cell::RefCell;

fn main() {
    let n = RefCell::new(123);
    let n1 = n.borrow();
    let n2 = n.borrow_mut();
}
```


RefCell 可以实现 interior mutability：在 immutable 的 RefCell 对象上创建出 mutable 引用。

> [!noto]
> RefCell 的本质是 unsafe 


常见用法：

```rust
let value = RefCell::new(5);

// 相当于获取 &mut，用完后马上销毁
*value.borrow_mut() += 1;

// 获取 &
println!("{}", value.borrow());
```


#### 引用循环

同时使用 `Rc` 和 `RefCell` 时，可能产生引用循环，造成内存泄漏，如：`RefCell<Rc<xxx>>` 

参考：[rust lang - reference cycles](https://doc.rust-lang.org/book/ch15-06-reference-cycles.html)


使用 `Weak<T>` 可以避免引用循环。

调用 `Rc::clone` 会增加引用计数 `strong_count`，而调用 `Rc::downgrade` 可以产生一个 `Weak<T>` 的智能指针，会增加 `weak_count` 计数。

使用 `Weak<T>` 之前，需要确保对象释放存在。需要调用 `upgrade` 方法，它返回 `Option<Rc<T>>` 。


树的实现：

```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    
    // 一般只能获取到 Rc<Node> 的节点，而 Rc<> 表示不可变引用。
    // 想要修改其内的内容，只能用 RefCell
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}
```


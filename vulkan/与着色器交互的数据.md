### 顶点属性

```glsl
layout (location = 0) in vec3 pos;
layout (location = 1) in vec3 normal;
```
注：属性数量是有限的，大概是 16 个，每个属性的尺寸是有限的（`vec4`）
例如：`mat4`需要占用 4 个 location


### 着色器之间的输入输出变量

```glsl
// fragment shder
layout (location = 0) in vec3 pos;
layout (location = 1) in vec2 uv;

layout (location = 0) out vec4 frag_color;
```
允许使用 `Interface Block`，可以设定 `memory layout`，例如 `std140`。


### descriptor

![[_attachments/image-19.png | 300]]

上述 `descriptor set`可以在 `shader`中这样访问：
```glsl
layout (binding = 0) uniform sampler2D texDiffuse;

layout (binding = 1) uniform UBO
{
    mat4 proj;
	  mat4 view;
} ubos[3];

layout (std140, binding = 2) buffer layoutName
{
    int some_int;
    float fixed_array[42];
    float variable_array[]; 	// 可变长度数组必须是最后一个
};
```

对于上述 `descriptor set`，其中 `UBO`和 `storage buffer`都是以 `Interface Block`的形式声明的。
`Interface Block`要有对应的 `memory layout`。


#### uniform buffer

如何让 `uniform buffer`生效？确保下面的线都是连通的：

![[_attachments/image-20.png | 300]]


#### storage image

可以将 image 当成二维数组来使用。
应用部分的代码：

- `layout`选择 `general`
- `aspect`选择 `color`。因为我们需要访问 RGB component。

glsl 部分的代码：
```glsl
layout(set = 0, binding = 1, rg32ui) uniform uimage2D name;

uvec4 val = imageLoad(uimage2D, ivec2(x, y));
imageStore(uimage2D, ivec2(x, y), uvec4(val));
```


### push constant

适合频繁更新的少量数据。频繁是指每帧更新，少量是指 `128byte`。
> `128byte`什么概念，也就 2 个 `Mat4x4`。


每个 `shader stage`只能有 1 个 `push constant`；
尺寸限制是指：所有 `shader stage`的 `push constant`尺寸加起来不超过。

**如何使用**：

将 `push constant`的信息添加到 `pipeline layout`中：
```cpp
VkPushConstantRange push_constant;
pipeline_layout = {
	.pushConstantRangeCount = 1,
    .pPushConstantRanges = &push_cosntant,
};
```

在绘制的指令中传递该数据：
```cpp
vkCmdPushConstant(...);
vkCmdDraw(...);
```

在着色器中使用 `push constant`：
```glsl
layout( push_constant ) uniform ColorBlock {
    vec4 Color;
} PushConstant;
```


### specialization constant

让应用在编译着色器时传入常量。


**如何使用**：

在创建 `shader stage`时，传入 `specialization constant`的实际数据：
```cpp
VkSpecializationInfo specialization_info = {
	.pmapEntries = ...,		// 每个常量的大小，以及 id
	.pData = ...,			// 实际的数据
};

VkPipelineShaderStageCreateInfo shader_stage = {
	.pSpecializationInfo = &specialization_info;
};
```

如果是计算着色器
在 `shader`中使用：
```glsl
layout (const_id = 1) const int NAME = 3;	// 需要提供默认值

// 使用 specialization const 来设定 compute shader 的参数
layout (local_size_x_id = 3) in;
```


### 计算着色器的 group shared memory

每个 `work group`都有 `shared memory`，着色器访问它的速度要比 `uniform buffer`或者 `storage buffer`更快。

在 `M1`芯片上的允许大小为 `32KB`。如果一个 `work group`的尺寸为 `8 x 8`，那么每个 `local invocation`最多可以分得 `500B`。

使用：在 `compute shader`中如下声明即可：
```glsl
shared vec4 sharedData[size];
```

`shared memory`一般会结合 `barrier`来使用。
`barrier`：屏障，字面意思。只有 `work group`的所有 `invocation`都到达这个位置后，`invocation`才能够继续向下走。


一般使用范式：

- 每个 `shader`向 `shared memory`中各自的区域写入数据
- 插入 `barrier`，确保所有 `invocation`都能够看到 `shared memory`中的最新数据。
- 写完之后，每个 `shader`再读取整个 `shared memory`


### 参考

- [Layout Qualifier (GLSL) - OpenGL Wiki](https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL))

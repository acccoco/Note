
#### 模板测试
开启模板缓冲后，每个像素都有一个模板值，模板值是一个 8 位的整形

模板测试的过程：
![[OpenGL/_attachments/image-42.png | 500]]

>[!warning]
> 一个坑：
> 在 `glClear(GL_STENCIL_BUFFER_BIT)` 之前一定要让模板缓冲可写 `glStencilMask(0xFF)` ，否则模板缓冲无法被清理


#### 模板测试的使用
模板测试的一般用法：在一次渲染中**写入**模板缓冲；在另一次渲染中**读取**模板缓冲
步骤为：

- 启用模板缓冲的写入
- 渲染物体，更新模板缓冲
- 禁止模板缓冲的写入
- 渲染其他物体，根据模板缓冲决定是否丢弃片段

第一阶段的作用是生成一个模板，所以不需要关注模板测试是否通过
```cpp
// 开启模板测试
glEnable(GL_STENCIL_TEST);
// 无条件通过模板测试
glStencilFunc(GL_ALWAYS, 1, 0xFF);
// 模板缓冲的每一位都允许写入
glStencilMask(0xFF);
// 根据需要设置模板测试/深度测试通过的行为
glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
```

第二阶段时实际的绘制过程，使用第一阶段生产的模板
```cpp
// 根据需要设置模板测试通过的条件
glStencilFunc(GL_EQUAL, 1, 0xFF);
// 模板的每一位都不允许写入
glStencilMask(0x00);
```

#### 例子：绘制物体的边框
实现效果：在物体周围有一层纯色的边框，该边框是一只可见的，不会被遮挡

思路：绘制过程：

- 绘制场景其他部分。
- 开启模板测试，设置模板可写，绘制物体。这一步是为了绘制物体，以及得到物体的模板。
- 关闭深度测试，设置模板不可写，使用纯色绘制放大一些的物体，只绘制模板值为 0 的位置，这一步是为了为了绘制边框。
- 关闭模板测试，开启深度测试。恢复环境。



参考这篇文章：
[Memory Barriers, a Hardware View for Software Hackers.pdf](https://www.yuque.com/attachments/yuque/0/2022/pdf/2323228/1657557740923-5474eae0-d994-416e-9d84-95475604bda8.pdf)



首先回顾一下 cache 的工作原理。
### cache 的工作原理
假设 CPU 架构和缓存结构如下图所示：
![[C++/并行编程/_attachments/CPU0.png|400]]
![[C++/并行编程/_attachments/Way_0.png|400]]

cache 可以理解为一个 hash table，允许 chain（上图中，最大 chain 长度为 2，即 Way 0 和 Way 1）。
每个 cache line 的大小是 `256 bytes`，hash function 很简单，直接取内存地址的低 9-12 位即可。
eg：
内存地址 `0x12345E00`和 `0x43210E00`经过 hash function 处理，对应同一个 cache 地址：`0xE`



为了保证多个 CPU 的缓存不会出现冲突，需要有缓存一致性协议，MESI 是其中一种 cache-coherence 协议


### MESI
MESI 的名字来源于它所支持的 4 种 cache state：

- Modified：cache line 中的 data 比 memory 新。当前 CPU 「own」这个 cache line，最终由这个 CPU 负责将 cache line 写回 memory 或转交给其他 CPU。
- Exclusive：cache line 中的 data 和 memory 一致。和 Modified 类型，当前 CPU「own」这个 cache line。
- Shared：cache line 中的 data 可以比 memory 新，也可以和 memory 一致。多个 CPU 中都有这个 cache line 的副本，此时 cache line 是「read only」的。
- Invalid：这个 cache line 是「empty」的，新的 data 可以放心写入。

MESI 提供了以下几种 message 来控制 cache 的 state 和 data 的改变：

- `Read(addr)`：向 memory 或者其他 CPU 请求 data。
- `Read Response(data)`：是 `Read()`的回复信息。
- `Invalidate(addr)`：某个 CPU 发出这个 message，让其他的对应 cache line 失效，这样这个 CPU 的 cache line 就是 modified 或 exclusive 状态了。
- `Invalidate Acknowledge()`：是 `Invalidate()`的回复。
- `Read Invalidate(addr)`：就等于 `Read() + Invalidate()`。
- `Writeback(addr, data)`：将 cache line 写回 memory。例如，cache 的空间不足了，就可以使用这个 message。

在 state 和 message 的控制之下，MESI 协议可以看成一个状态机：
![[C++/并行编程/_attachments/EMSI.svg|400]]



根据上面的信息可以得知，CPU 在**第一次**将 data 写入 cache 时比较耗时，
具体的过程如下：

- 首先向其他 CPU 发送 `Invalidate()`message。
- 其他 CPU 将对应的 cache line 无效化，回复 `Ack()`。
- 收到 `Ack()`，将数据写入 cache line。

![[C++/并行编程/_attachments/CPUO.png|200]]
引入 store buffer 可以有效解决这个问题。
### store buffer 与 write memory barrier
在 CPU 和其专用 cache 之间设置 store buffer。
store buffer 作用：

- 因为 write 而发生 cache miss 时，CPU 直接将要写的数据放入 store buffer，然后向其他 CPU 发送 `Invalida()`消息，之后 CPU 可以执行后续的工作，而不用等到 `Ack()`。
- 收到其他 CPU 发来的 `Ack()`后，当前 CPU 就可以把 store buffer 中的 data 放入 cache 了。

![[C++/并行编程/_attachments/CPU_O.png|200]]

使用 store buffer 可能会导致 global memory reordering，需要 write memory barrier 来修复。
write memory barrier 的作用是「mark store buffer」，确保在「其后的 store op」执行之前，「其前方的 store op」都已经执行完毕。（eg. flush store buffer）

用一个例子来说明 store buffer 和 write-memory-barrier 的作用，初始状态为：
要执行的代码：(`smp_mb`处只用 `smp_wmb`就够了）
![[C++/并行编程/_attachments/image-2.png|200]]
cache 状态为：
CPU 0: b = 0, Exclusive
CPU 1: a = 0, Exclusive


执行过程如下：（左边是 CPU 0，执行 `foo()`；右边是 CPU 1，执行 `bar()`）
![[C++/并行编程/_attachments/store_buffer.svg|400]]




store buffer 的容量是有限的，如果 CPU 频繁地进行 store，那么最终还是需要等待其他 CPU 的 `Invalidate Ack`。
为什么等待 `Ack`非常耗时？
考虑这样的情况：一个 CPU 同时收到来自多个 CPU 的 `Invalidate`，它需要一个一个处理，这意味着总有一个 CPU 是最后一个收到 `Ack`的，也就意味着那个 CPU 需要等待「很长」一段时间。
为每个 CPU 引入 `invalidate queue`可以改善这一个情况。
### Invalidate Queue 与 read-memory-barrier
`Invalidate Queue`的作用是：

- CPU 收到 `Invalidate`消息后，并不马上处理，而是将其放入 `Invalidate Queue`中，并马上回复 `Ack`。
- 稍后再处理 `Invalidate Queue`中的消息

![[C++/并行编程/_attachments/image.png|200]]


使用 `Invalidate Queue`，可能会破坏 globa memory ordering，可以通过 read-memory-barrier 来进行修正。
read-memory-barrier 的作用是：可以确保在「其后方的 load 执行之前」，「其前方的 `invadlidate queue`」都已经被处理过了。也就是，mark invalidate queue。

用一个例子来说明 invalidate queue 和 read-memory-barrier 的作用：
执行的代码如下：（`foo`中只需要 `smp_wmb()`就够了，`bar`只需要 `smp_rmb()`就够了。）
![[C++/并行编程/_attachments/image-1.png|200]]


CPU 0 执行 `foo()`，CPU 1 执行 `bar()`
CPU 0 中的 cache：
`(shared) a = 0; (exclusive) b = 0`
CPU 1 中的 cache：
`(shared) a = 0`

执行过程如下：
![[C++/并行编程/_attachments/invalidate_queue.svg|400]]



### memory barrier
通过上面的例子，已经了解到了最基本的 memory barrier：

- `read memory barrier`：用于 mark `invalidate queue`，作用是，避免 CPU 读到自己的 cache 中的九数据。
- `write memory barrier`：用于 mark `store buffer`，作用是，让 CPU 将数据及时地更新到 main memory。

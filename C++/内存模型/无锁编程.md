
### 无锁编程

无锁编程才需要考虑 reorder 的问题。
无锁编程常常使用 `atomic`，`memory barrier`，以及 `RMW operation`
无锁编程需要小心 ABA 问题。


#### ABA 问题

用下面这个例子来说明：
```cpp
template <typename Data> struct Element {
  Data mData;
  Element<Data> *mNext;
};

template <typename Data> class Stack {
public:
  using Obj = Element<Data>;
  std::atomic<Obj *> mHead;

  void Push(Obj *newObj) {
    newObj->mNext = mHead.load();
    while (!mHead.compare_exchange_weak(newObj->mNext, newObj))
      ;
  }

  Obj *Pop() {
    Obj *old_head = mHead.load();
    while (1) {
      if (old_head == nullptr)
        return nullptr;
      if (mHead.compare_exchange_weak(old_head, old_head->mNext))
        return old_head;
    }
  }
};
```
上面的代码，`Push`没有任何问题，`Pop`会出现问题。考虑以下情形：

- thread 1 从 `old_head->mNext`中读取完成（假设读到的节点为 B），在 `compare_exchange_weak`前阻塞了
- thread 2 先 pop 当前的 node A，然后 push 一个其他 node C，最后在 push 原来的 node A
- thread 1 再次执行，发现 `mHead`和 `old_head`是一样的，于是将 `old_head->mNext`设为新的 `mHead`

结果就是，thread 2 插入的 node C 从 stack 中消失了。
例子来源：[https://stackoverflow.com/questions/26747265/simple-lock-free-stack-c11](https://stackoverflow.com/questions/26747265/simple-lock-free-stack-c11)



#### DCLP

double check lock pattern 用好了可以有效提高效率。
以单例模型为例，可以这样写：
```cpp
Singleton* Singleton::getInstance() {
    Lock lock;
    if (m_instance == NULL) {
        m_instance = new Singleton;
    }
    return m_instance;
}
```
实际上，只有最开始创建 `Singleton`的时候是需要 `lock`的，后续访问 `Singleton`是不需要 `lock`的。

可以用 DCLP 来改写上述代码：
```cpp
std::atomic<Singleton*> Singleton::m_instance;
std::mutex Singleton::m_mutex;

Singleton* Singleton::getInstance() {
    Singleton* tmp = m_instance.load(std::memory_order_relaxed);
    std::atomic_thread_fence(std::memory_order_acquire);
    if (tmp == nullptr) {
        std::lock_guard<std::mutex> lock(m_mutex);
        tmp = m_instance.load(std::memory_order_relaxed);
        if (tmp == nullptr) {
            tmp = new Singleton;
            std::atomic_thread_fence(std::memory_order_release);
            m_instance.store(tmp, std::memory_order_relaxed);
        }
    }
    return tmp;
}
```

这这个例子中，`m_instance`是 Guard，`Singleton`中的内容是 payload，因此可以用 release-acqurie 来解决。

建立的 synchronizes-with 关系如下：

![image.png](C++/内存模型/_attachments/image-1.png)
如果没有建立同步关系，那么 thread 2 可能看见这样的情况：系统以及为 `Singleton`分配了内存空间，但是还没有向内存中填入内容（执行构造函数）。

注：上面的例子中，使用 `consume`是最好的。

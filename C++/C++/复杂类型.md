复杂类型的读法：顺时针原则。
具体规则如下：

- 从变量名称开始，顺时针读取
- 先处理括号内的，再处理括号外的
- 遇到函数，先寻找参数列表，再寻找返回类型

参考文章：
[https://vincentqin.tech/posts/clockwise-rule/](https://vincentqin.tech/posts/clockwise-rule/)

### 复杂类型
#### `int *v[5]`
![[C++/C++/_attachments/Pasted_Graphic.png | 400]]


`v` 是一个长度为 `5` 的数组，数组元素是指向 `int` 的指针。

#### `int (*v)[3]`
![[C++/C++/_attachments/一.png | 400]]


`v`是一个指向数组的指针，数组元素是 `int`。


### 复杂函数类型

#### `int (*(*v)[])()`

![[C++/C++/_attachments/Pasted_Graphic_2.png | 400]]

`v`是一个长度为 `3`的数组的指针，数组元素是函数，函数签名是 `() => int`。
注：

- 第 4 步遇到函数，可以确定函数的参数列表
- 从第 5 步开始的后续步骤都是确定函数的返回类型了

#### `char (*(*v[3])())[2]`

![[C++/C++/_attachments/typof_v_图团因.png | 400]]


`v`是一个长度为 `3`的数组，数组元素是函数指针，函数没有参数，函数的返回值是长度为 `2`的 `char`数组的指针。
注：

- 在第 3 步时，开始处理函数，可以知道函数没有参数
- 从第 4 步开始寻找函数的返回类型，后面的全部都是在解决函数的返回类型


### `const`标识符
`const`标识符也可以用这个方法来读：

`const char *`和 `char const *`这两种类型是等价的，都是指向常量字符的指针：
![[C++/C++/_attachments/Pasted_Graphic_4.png | 400]]


`char * const`是指向字符的常量指针：
![[C++/C++/_attachments/Pasted_Graphic_5.png | 400]]



注：遇到`const`，从右往左读，最快。
### 数组用作函数参数
编译器可以知道栈上数组的尺寸，例如：
```cpp
int arr[3];
sizeof(arr);
// 12 = 3 * sizeof(int)
```
 
如果数组作为函数的参数，参数的类型会**退化**为一个普通的指针：
```cpp
void foo(int acc[3])
{
    sizeof(acc);
    // 8 = sizeof(int*)
}
```

数组的指针则不存在退化的问题：
```cpp
void foo(int (*ptr)[3])
{
    sizeof(ptr);	// 8 = sizeof(T*)
    sizeof(*ptr);	// 12 = sizeof(int[3])
}
```

#### 定长数组的应用
例如：
```c
#define JMP_INS_SIZE 5
typedef unsigned char ins_backup_t[JMP_INS_SIZE];

/**
 * @brief 动态打桩函数
 * @param [in]old_func 需要被替换的函数
 * @param [in]new_func 要替换成什么函数
 * @param [out]buff 备份原函数入口处的指令
 */
void stub(void* old_func, void* new_func, ins_backup_t *backup)
{
    /// ...
    memcpy(*backup, olf_func, sizeof(*backup));
    /// ...
}

int main()
{
    ins_backup_t malloc_backup;
    stub(malloc, my_malloc, &malloc_backup);
}
```


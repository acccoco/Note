参考这个：[stackoverflow - why-use-static-castintx-instead-of-intx](https://stackoverflow.com/questions/103512/why-use-static-castintx-instead-of-intx)

## 隐式转换
##### 1. 基本类型
```cpp
int a = true;
```

- 如果从高精度转换为低精度，会出现警告

##### 2. 自定义类型
```cpp
class MyClass 
{
public:
    MyClass(int a) {}
    MyClass(const char* p) {}
};

int main() 
{
	MyClass c1 = 10;			// MyClass(10)
    MyClass c2 = "acc";		    // MyClass("acc")
}
```

##### 3. 使用`explicit`禁止隐式转换

- `explicit`专门用于构造函数，可以抑制隐式转换
```cpp
class MyClass 
{
public:
    explicit MyClass(int a) {}
};

int main() 
{
	MyClass c1 = 10;						// error
    MyClass c2 = MyClass(10);				// ok
}
```

## C风格的显式转换
```cpp
double dValue = 100.2;
int nValue = (int)dValue;
void* ptr;
MyClass* myClassPtr = (MyClass*)ptr;
```

## C++风格的转换

> [!info] 参考这个
> [知乎 - C++ 四种cast](https://www.zhihu.com/question/493328539/answer/2737307729?utm_medium=social&utm_oi=551847284401283072&utm_psn=1570393261373349889&utm_source=ZHShareTargetIDMore)

`dynamic_cast<T>`

- 可以将子类型转换为父类型，父类型转换为子类型，不会进行类型检查
- 向上转换（upcast）是安全的；向下转换（downcast）不会进行运行时检查，不安全。

`dynamic_cast<T>`

- 将子类型转换为父类型时，同 static_cast<T>
- 将父类型转换为子类型时，会进行类型检查。类型检查是通过虚表来实现的，所以要求父类必须要有虚函数

用于智能指针的类型转换：
`static_pointer_cast<T>`

`dynamic_pointer_cast<T>`

`const_cast<T>`

- 将常量指针，对象，引用转化为非常量






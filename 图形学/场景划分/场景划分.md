游戏场景管理一般用的是「松散八叉树」
BVH 一般用于离线渲染


### 网格划分
网格划分是一种均匀的划分方法。
![[图形学/场景划分/_attachments/gbamK_image.png | 221]]![[图形学/场景划分/_attachments/amHWm_image.png | 237]]


### 八叉树
划分方法：

- 每个节点都是 AABB 包围盒，子节点的包围盒位于父节点内部，只有叶子节点才存储 `object`。
- 如果节点对应的空间是空旷的，不再进行划分
- 如果节点只包含少量物体，可以不再进行划分

![[图形学/场景划分/_attachments/a85uE_image.png | 172]]


#### 松散八叉树
游戏中使用的八叉树是松散八叉树：子节点的范围会比正常八叉树的范围大一圈，子节点之间会有重叠。松散八叉树可以解决边界问题，减少八叉树的更新次数。
![[图形学/场景划分/_attachments/u003e9084_image.png | 308]]

如果物体发生移动，只需要调整少数节点即可，因此八叉树很适合管理游戏的场景。
八叉树的查找效率低于 BVH，但是只用来做 Frustum Culling，够用了。




### 层次包围盒树 BVH
BVH，Bounding Volume Hierarchy
划分方法：对节点内的物体分组，为分组后的物体建立新的包围盒，作为子节点。
包围盒可以是 AABB，也可以是 OBB，还可以是包围球。

注：兄弟节点的包围盒可能互相重叠。
![[图形学/场景划分/_attachments/wb3uJ_image.png | 453]]

为了保证划分比较均匀，划分的轴可以是包围盒长度最长的那个方向。
![[图形学/场景划分/_attachments/u1c71e94b_Pasted Graphic 1.png | 323]]

BVH 与光线求交：递归查询即可，子节点的 AABB 一定位于父节点 AABB 内部的。
查询过程如下：
```python
if ray.hit(root_box):
    if ray.hit(root_box.left_subtree):
        check intersection
    if ray.hit(root_box.right_subtree):
        check intersection
        
    # 分情况讨论：交点数 2，1，0 都有可能
    if left_intersect && right_intersect:
        return closest(left_inter, right_inter)
    else if left_intersect || right_intersect:
        return that inter
    else:
        return no inter
else:
	return no inter
```
注：与父 AABB 相交，不一定与子 AABB 也有交点

应用：

- 光线追踪
- 视锥剔除


### BSP
binary space partitioning tree
在 2D 情形下，形状的基本组成元素是直线，一条直线可以将场景划分为两个部分。

如下图：

- 最开始使用线条 `A`将图形划分为 2 个部分，其中线条 `E`被截断为 `E1`和 `E2`两个部分

![[图形学/场景划分/_attachments/u8a001b1f_Pasted Graphic.png | 289]]

**BSP 树可以将任意形状划分为多个凸多边形**：
（凸多边形的形状：任意一条边都位于其余边的前方）
![[图形学/场景划分/_attachments/u1ea84a48_Pasted Graphic 1.png | 430]]

划分凸多边形可以用于构建导航网格。


**BSP 实现画家算法**：
（在硬件 depth test 后，这种方法已经被舍弃了）
如下图：使用 BSP 划分场景，其中 `V`是观察点：
![[图形学/场景划分/_attachments/udc99bfb5_Pasted Graphic 2.png | 404]]

绘制顺序为：确定一个参考平面，观察点为 `V`，应该先绘制异侧的物体，再绘制参考平面，最后绘制同侧的物体。
最终的绘制顺序为：
![[图形学/场景划分/_attachments/uff0222aa_Pasted Graphic 3.png | 324]]



### KD Tree
`KD-Tree`是二叉树，使用平行于坐标轴的超平面来划分空间，中间节点表示用于划分的平面。
`KD-Tree`可以看作是轴对齐的 `BSP`
例如：
![[图形学/场景划分/_attachments/u87bf696a_image.png | 293]]
![[图形学/场景划分/_attachments/ua16f6b3f_image.png | 225]]


### 参考

- [空间数据结构(四叉树/八叉树/BVH树/BSP树/k-d树) - KillerAery - 博客园](https://www.cnblogs.com/KillerAery/p/10878367.html)
- [https://en.wikipedia.org/wiki/Binary_space_partitioning](https://en.wikipedia.org/wiki/Binary_space_partitioning)
- [http://www.sccg.sk/~samuelcik/dgs/04_en.pdf](http://www.sccg.sk/~samuelcik/dgs/04_en.pdf)
- [游戏场景管理中BVH相比八叉树有什么优劣？ - 知乎](https://www.zhihu.com/question/48905832/answer/2664911942?utm_medium=social&utm_oi=551847284401283072&utm_psn=1551192826700050433&utm_source=ZHShareTargetIDMore)


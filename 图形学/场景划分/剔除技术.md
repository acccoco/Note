
### 预计算可见性
首先将场景划分为一个个 Cell
场景中的静态物体：对于每个 Cell，计算出摄像机位于其中时能够看到的物体范围。
![[图形学/场景划分/_attachments/ucb512425_image.png | 388]]


### Portal Culling
（Unity，Control）
室内场景用的比较多。
将场景划分为一个个 Cell，预计算相邻 Cell 之间的连通性。
（场景的划分可以通过 BSP 来自动完成）
渲染时，根据摄像机所在的 Cell 以及观察方向，可以快速剔除一些物体。


### 软光栅剔除
运行软光栅，渲染最低精度的场景，获得场景的深度信息。使用 GPU 渲染时，可以利用软光栅得到的深度信息剔除部分物体。
和视锥剔除相比：视锥剔除只能剔除视锥之外的物体，软光栅剔除可以剔除视锥之内的物体。
![[图形学/场景划分/_attachments/u47a0dbd2_image.png | 270]]


### 遮挡查询 Occlusion Query
（UE4）
遮挡查询是图形 API 的功能。
首先进行 depth-pass，得到 z-buffer，然后将物体的包围盒传给 GPU 做遮挡测试，CPU 从 GPU 读回数据。
（depth-pass 大概只渲染场景中的静态物体）
这种做法延迟较高。


### HZB
（UE4，原神）
Hierarchical z-buffer
HZB 就是 z-buffer 的 mipmap，和 color mipmap 的生成方法不同，HZB 取的是区域像素中的最值而不是平均值。
![[图形学/场景划分/_attachments/u21cd79e5_image.png | 298]]

首先得到场景中静态物体的 HZB，然后将待剔除物体的包围盒做深度测试，计算可以在「compute shader」中进行。
在屏幕中尺寸越大的物体，应该使用越粗糙的 z-buffer 来测试。
![[图形学/场景划分/_attachments/uc89a1278_image.png | 338]]


### 视锥剔除
Frustum Culling：视锥体之外的物体，没有必要传递到 GPU，这种技术可以减少将数据传输到**G-RAM** 的时间。

一般做法：对场景进行**空间划分**或者**层次划分**，精准地找到 Frustum 之内的物体。

**如何判断视锥体和长方体包围盒（AABB，OBB）相交**：
可以分别对长方体的 8 个顶点进行投影变换，判断变换后的点是否位于 NDC 之内。也就是模拟 GPU 的视锥剔除过程。


### 硬件剔除
背面剔除

**提前的深度测试**：z-max culling，z-min culling，early-z
GPU 在使用 tile 时，会记录 tile 中的最大深度值和最小深度值。
（深度值范围从近到远为 `[0, 1]`，初始深度值为 `1`）

z-max culling：如果三角形的最小深度值 比 `tile` 的最大深度值 还要大，那么说明三角形完全不可见，不用绘制。
z-min culling：如果三角形的最大深度 比 `tile` 的最小深度 还要小，那么说明三角形的所有像素都可见，不用进行后续的深度测试。

early-z：在 `fragment shader`执行之前，会进行一次深度测试，如果测试不通过，则丢弃这个像素点。

正常的深度测试发生在 `fragment shader`之后，也叫做 `late depth test`


### 参考

- [游戏中的剔除技术（二）视锥剔除和硬件剔除](https://zhuanlan.zhihu.com/p/437399913)
- [游戏中的剔除技术（一）遮挡剔除/Occlusion Culling](https://zhuanlan.zhihu.com/p/363277669)

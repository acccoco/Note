---
tag: hdr
---


抗锯齿总体来说有两种方法：

1. 增加采样数量
2. 使用后处理的方法来模糊图像


### SSAA
SSAA：super sample anti aliasing
SSAA 就是粗暴地增加采样点的数量，然后再使用 box filter 得到更少采样数的结果。


**ssaa 为什么有效**：

- 增加采样点：减少混叠
- resolve：降低混叠信号的强度

![[图形学/反走样/_attachments/Pasted_Graphic_4.png | 500]]


### MSAA

MSAA：multi sampling anti aliasing

>[!warning]
> 在渲染头发，细绳等小物体的时候，MSAA 就十分有效，而 post-process 的 AA 不那么有效。


MSAA 的基本原理：如果 pixel 能够覆盖所有的 sample，那么只需要执行一次 `fragment shader`；如果只能覆盖部分的 sample，硬件可以调整 `fragment shader`计算的位置；最后将计算结果放入几个 `sample`中。
![[图形学/反走样/_attachments/Pasted image 20221031011422.png | 300]]


上图中：红色三角形覆盖了 3 个 `sample`，`fragment shader`的执行位置位于 `pixel`的中央；蓝色三角形只覆盖了 1 个 `sample`，`fragment shader`的执行位置就位于采样点上。

注：MSAA 相比于 SSAA，能够节省计算资源，不会节省内存使用（NVIDIA 的 CSAA 和 AMD 的 EQAA 除外）。


#### 采样模式

`sample`点的放置位置会显著影响 AA 的效果。

常见的模式如下，这些模式已经写入了硬件中：
![[图形学/反走样/_attachments/Pasted_Graphic_3.png | 400]]


为什么 RGSS（rorated grid）比普通的 2x2 grid 效果要好：
![[图形学/反走样/_attachments/image-2.png | 500]]


一个原因是：RGSS 相比于 2x2 grid，增加了水平和竖直的分辨率。


FLIPQUAD 这种模式，效果和 RGSS 近似，但是采样数量只有原来的一半：
![[图形学/反走样/_attachments/image.png | 400]]



#### MSAA 与 HDR

开启 MSAA 后，得到的渲染结果分辨率是原来的多倍，需要经过 `resolve`得到屏幕分辨率的图像。
`resolve`过程就是多个像素取取平均值，也就是 box filter 的过程。

如果渲染过程使用的是 HDR，那么需要先 tone mapping，将 HDR 映射到 SDR，再进行 resolve，否则得到的结果仍然是有明显的锯齿。

例如：（假设每个像素有 2 个 sample）

![[图形学/反走样/_attachments/ACES_Curve.png | 400]]
![[图形学/反走样/_attachments/Pasted_Graphic_5.png | 500]]


根本原因在于：tone map 变换并不是线性变换。


#### MSAA 与延迟渲染

首先明确在延迟渲染中使用 MSAA 的具体步骤：

- 在 G-pass 中开启 MSAA，生成多倍分辨率的 GBuffer
- light-pass 中使用的 framebuffer 分辨率应该和 GBuffer 一致
- 最后进行 resolve

MSAA 在延迟渲染中的主要问题是：带宽问题和计算问题。

**带宽问题**：GBuffer 本身已经很大了，使用 MSAA 后会让 GBuffer 翻很多倍，带宽很受影响。

**计算问题**：light-pass 并不知道哪些 fragment 是重复的，因此可能会有重复计算。

> DX11 会给每个 sample 分配一个位掩码 `SV_Coverage`，用于标记该 sample 是否是重复的，因此这个问题得以解决。
> ![image.png](图形学/反走样/_attachments/image-1.png)
> [NVIDIA Antialiased Deferred Rendering](https://docs.nvidia.com/gameworks/content/gameworkslibrary/graphicssamples/d3d_samples/antialiaseddeferredrendering.htm)



### TAA

TAA 的基本思路也是复用前几帧的 `sample`，以达到增加 `sample` 的目标。
`sample`的分布模式要尽量随机且均匀，可以选择「低差异序列」。

**如何调整** `sample` **在** `fragment` **中的位置，修改投影矩阵即可**：

```glsl
// 注：NDC xy 的范围是 [-1, 1]，随机数的范围是 [0, 1]
delta_x = (rand.x * 2.f - 1.f) / screen.width;
delta_y = (rand.y * 2.f - 1.f) / screen.height;
```

正交投影矩阵和透视投影矩阵修改的位置不同

![[图形学/反走样/_attachments/Pasted_Graphic.png | 200]]


**如何确定不同帧之间像素的对应关系**：`motion vector`
![[图形学/反走样/_attachments/motion_vector.svg | 300]]


如何获得 `Model`矩阵：可以在 GBuffer 中存放物体 ID，然后根据 ID 查找对应的 `Model`矩阵。`Model`矩阵可以用 `storage buffer`存放。


### 基于形态的抗锯齿

主要思路是：通过亮度，对比度来寻找图像的边界，然后对边界进行平滑处理。

常见的有：FXAA，SMAA


注：FXAA 在处理高亮部分时不太稳定，动态场景会出现闪烁的情况。



### 参考

- [A QUICK OVERVIEW OF MSAA](https://mynameismjp.wordpress.com/2012/10/24/msaa-overview/)
- [主流抗锯齿方案详解（一）MSAA](https://zhuanlan.zhihu.com/p/415087003)
- [主流抗锯齿方案详解（二）TAA](https://zhuanlan.zhihu.com/p/425233743)
- [主流抗锯齿方案详解（三）FXAA](https://zhuanlan.zhihu.com/p/431384101)
- [主流抗锯齿方案详解（四）SMAA](https://zhuanlan.zhihu.com/p/342211163)
- [游戏中的后处理：色彩空间、ACES、Tonemapping和HDR](https://zhuanlan.zhihu.com/p/118272193)
- RealTime Rendering 4th, 5.4 Aliasing and Antialiasing


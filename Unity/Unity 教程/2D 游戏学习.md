### 通过精灵创建游戏对象

将一张「png」图片拖动到 Assets 中可以自动创建精灵：

- 可以将多个精灵放在一张图片上，Unity 可以将其切分开来
- 可以设置游戏场景中的一个单位对应图片的多少个像素

![[Unity/Unity 教程/_attachments/image-3.png |  300]]

![[Unity/Unity 教程/_attachments/Pasted image 20221029220241.png | 300]]


通过精灵创建游戏对象，关键在与「Sprite Render」这个组件
下图是一个游戏对象的 Inspector：

![[Unity/Unity 教程/_attachments/image-9.png | 300]]


### 游戏对象的碰撞与接触
「Rigidbody 2D」组件提供物理模拟，可以视情况去掉角色的重力属性：

![[Unity/Unity 教程/_attachments/Pasted image 20221029221135.png | 300]]


「Collider 2D」组件提供碰撞检测，只有当两个对象都具有「Collider」组件时，才能够进行碰撞检测。
注：两个具有「Collider」组件的对象无法重叠在一起，可以通过以下函数来检测是否发生碰撞：
```csharp
void OnCollisionEnter2D(Collision2D other) {
	GameObject obj = other.gameObject;
}
```

如果只想要判断物体是否互相接触，而不想要物体在接触时被弹开，可以将一者设置为「触发器」：

![[Unity/Unity 教程/_attachments/image-12.png | 300]]


可以通过以下函数判断是否发生接触：
```csharp
void OnTriggerEnter2D(Collider2D other) {
	GameObject obj = other.gameObejct;
}
```


**判断角色是否和物体接触**：
可以通过如下函数判断：
```csharp
void OnTriggerStay2D(Collider2D other) {}
```

为了防止角色停止移动时物理引擎不进行计算，应该对角色进行如下设置：

![[Unity/Unity 教程/_attachments/image-7.png | 300]]


### 角色控制
可以通过修改「Transform」组件的位置来移动游戏对象：
```csharp
transform.position = newPosition;
```

**抖动的发生和解决**：
如果游戏对象具有「Collider」组件，并且朝另一个同样具有「Collider」组件的对象移动，且接触在一起，此时可能发生抖动。
因为修改「Transform」组件的位置后，有可能发生「Collider」互相重叠的情形，由于物理系统不允许「Collider」发生重叠，因此物体会相互弹开。整个过程发生在极短的时间内，运动幅度极小，最后表现为抖动。
解决办法是，使用「collider」组件来进行移动：
```csharp
void FixedUpdate() {
	rigidbody2d.position = newPosition;
}
```

注：为什么是在「FixedUpdate」中更新位置而不是在「Update」中。因为「Update」是与渲染有关的，调用频率是未知的；「FixedUpdate」的调用频率是确定的，为了使「物理系统」平稳的工作，**应该在「FixedUpdate」中进行与物理相关的修改**。

**禁止旋转**：
碰撞体互相紧贴着对方移动时，可能会发生旋转，可以禁止旋转：

![[Unity/Unity 教程/_attachments/image-17.png | 300]]


**检查输入**：
Unity 在实际的键盘之上进行了一层抽象，可以通过「Project Setting -> Input Manager」来进行配置：
![[Unity/Unity 教程/_attachments/image-5.png | 500]]

注：上述的「Horizontal」会被平滑处理

获取输入的代码：
```csharp
float horizontal = Input.GetAxis("Horizontal");
```

**整个进行移动的代码可以如下**：
```csharp
public float moveSpeed;
float horizontal;
float verticall;

void Update() {
	horizontal = Input.GetAxis("Horizontal");
    vertical = Input.GetAxis("Vertical");
}

void FixedUpdate() {
	rigidbody2d.position += moveSpeed * Time.deltaTime 
        * new Vector2(horizontal, Vertical);
}
```
注：上述的 `Time.deltaTime` 使得移动速率与帧率无关

### 瓦片地图
在场景中创建一个「tilemap」对象：
![[Unity/Unity 教程/_attachments/Pasted image 20221029221340.png | 400]]

使用「Tile Palette」（调色板）在地图上进行绘制。打开「tile palette」的 window，将需要的素材放入其中：
![[Unity/Unity 教程/_attachments/image-16.png | 300]]

在调色板中选择一块，在场景中进行绘制

**为地图添加碰撞体**：
为地图添加「tilemap collider 2d」的组件，此时整个地图是一个大的碰撞体
选择不需要视为碰撞体的瓦片（在 Assets 中去选择），然后进行如下设置：
![[Unity/Unity 教程/_attachments/image-6.png | 300]]

通过为地图添加「composite collider 2d」组件来简化碰撞体的计算：
![[Unity/Unity 教程/_attachments/image-8.png | 300]]

### 调整绘制顺序
如何确保角色位于地图的上方，通过修改绘制顺序实现：

![[Unity/Unity 教程/_attachments/Pasted image 20221029221405.png | 300]]

如何确保场景中的其他物体和角色的空间关系正确：
![[Unity/Unity 教程/_attachments/image-4.png | 150]]（角色应该被植物遮挡）

可以在「project setting -> graphics」中设置按照 y 轴来排序
![[Unity/Unity 教程/_attachments/Pasted image 20221029221448.png| 400]]

将排序的参考点设置为「pivot」，并且调整精灵「pivot」的位置：
![[Unity/Unity 教程/_attachments/image-15.png | 400 ]]![[Unity/Unity 教程/_attachments/image-11.png | 400]]

### 计时器
很多情景需要用到计时器
计时器可以进行如下抽象：
```csharp
public float maxTime;
private float timerRemain;

void Start() {
	timerRemain = maxTime;
}
void Update() {
	if (timerRemain > 0.0f) {
    	timerRemain -= Time.deltaTime;
        if (timerRemain < 0.0f) {
        	// 进行操作
        }
    }
}
```

### 精灵动画
播放动画的对象需要有「Animator」组件，它具有一个控制器，实际上就是一个状态机，状态机的状态就是动画「Animation」。

**制作动画**：
打开 Animation 窗口，并且选中一个游戏对象，将动画每一帧代表的精灵拖动到 Animation 窗口。然后创建一个动画「Clip」
如图是一个「RubyIdleLeft」的动画 Clip，每秒 4 帧
![[Unity/Unity 教程/_attachments/image-14.png | 400]]

**动画的控制器**：
动画的控制器，也就是状态机，在 Animator 窗口：
![[Unity/Unity 教程/_attachments/Pasted image 20221029221513.png | 600]]
通过代码设置状态机的参数：
```csharp
animator.SetFloat("Move X", 0.1f);
animator.SetTrigger();
```

### 发射子弹
如何实现子弹发射：

- 首先要有一个子弹对象的预制件
- 发射时实例化该预制件
- 为子弹施加力来进行发射
- 使用计时器来销毁子弹
```csharp
// 角色的脚本
GameObject bulletPrefab;
void Launch() {
	GameObject bullet = Instantiate(bulletPrefab, rigidbody2d.position
                                    , Quaternion.identity);
    bullet.GetComponent<Bullet>().Launch();
}

// 子弹的脚本
void Launch(Vector2 direction, float force) {
	rigidbody2d.AddForce(direction * force);
}

void Update() {
	timer -= Time.deltaTime;
    if (timer < 0.0f)
        Destroy(gameObject);
}
```

注：实例化之后并不会立刻执行 `Start` 函数，所以初始化的内容应该放到 `Awake` 函数中进行。

### 图层
可以为不同的物体设置不同的图层，然后设置哪些图层可以进行物理交互：
![[Unity/Unity 教程/_attachments/image-13.png | 500]]

### 摄像机
使用 Cinemachina 这个包来实现摄像机跟随角色，限制摄像机的运动范围等操作

### 粒子系统
粒子系统由发射器和发射的材料组成，可以为粒子系统指定一些精灵来发射

### UI
如果要将 UI 添加到场景中，首先需要添加一个 canvas 对象。
UI 相关的对象使用 RectTransform 来确定位置和大小

- pivot：是大小和尺寸的测量起点
- anchor：锚定到父对象，当父对象的大小改变时，自动改变当前对象的大小。

### 世界交互
通过物理系统的射线投射功能来检测交互对象是否站在角色面前。
当然也可以使用触发器来实现，但是触发器没法检测交互对象是否面对面。
相关代码：
```csharp
RaycastHit2D hit = Physics2D.Raycast(position, direction, length, layer);
if (hit.collider != null) {
	// 进行交互
}
```

### 音频
声音系统由三个部分组成：

- listener：这个组件一般位于摄像机上面
- audio source：这个组件表示声音的发出者
- audio clip：表示声音片段，比如一个 mp3 文件

声音交互的实现方案之一：

- 声音发出者（source）是角色
- 声音片段来自交互对象
```csharp
// 角色的脚本
void PlaySound(AudioClip clip) {
	audioSource.PlayOneShot(clip);
}

// 交互对象的脚本
void Interact() {
	player.PlaySound(clip);
}
```


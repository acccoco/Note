
## 游戏引擎的层次划分

一种层次划分：

- 工具层：编辑器
- 功能层：渲染，动画，物理，脚本，HUD
- 资源层：数据，文件
- 核心层：容器，内存，线程，数学
- 平台层：处理硬件差异，操作系统，图形API


## 游戏世界的组成

### 各种 GameObject 

动态系统：人物，车辆

静态系统：建筑，装饰

环境：

- 地形系统
- 天空
- 植被

其他游戏对象：

- 碰撞体，触发器
- 导航模型
- 游戏规则的 GameObject


### 如何实现游戏对象

可以直接用面相对象的方法去抽象：属性，方法，继承。

面向对象的类型系统不好用，组件系统可以解决这个问题。

最后的实现是：

- 使用 GameObejct 来抽象各种对象
- 使用 Component 来表示对象的各种特征


### 游戏对象动起来

tick 的两种方法：

- 逐对象 tick：简单，直觉
- 逐系统 tick：有利于并行，缓存友好

![[../图形引擎/_attachments/Pasted image 20221208155603.png]]

如果 GO 之间存在绑定关系（父子），那么 tick 的顺序需要特别注意。

> 例如 ECS 系统


### 游戏对象相互通信

以炸弹爆炸为力：

- 直觉的方法：由炸弹来检测爆炸范围内的所有物体，并相应处理
- event 机制：炸弹向范围内的所有对象发送事件

GO 之间如果能够直接传递消息，那么游戏对象的行为可能会是不可预测的（例如近战时同时击中对方，可能会出现一方攻击成功，另一方受击从而攻击失败）

引入一个中间机制，当前帧将 event 发送到队列，下一帧接收 event。pretick 和 posttick 也可以解决这个问题。

还有组件之间的互相影响：脚本影响位置，影响动画，影响物理。这些影响是在下一帧才会生效的，还是当前帧就会生效。

> 总而言之，就是各种时序。


### 游戏对象管理

场景管理：空间均匀划分，空间层次划分（八叉树），对象层次划分（BVH），场景图（节点，父子层次）




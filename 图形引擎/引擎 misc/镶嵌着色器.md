
tessellasion 由三个阶段组成：

- TCS(control shader)：设置细分级别，填充基础的顶点属性，在原始的顶点上逐顶点执行
- 图元生成阶段：这个阶段不可编程。GPU 会根据细分级别，在「抽象 patch」的基础上，新生成多个顶点
- TES(evaluation shader)：在新生成的顶点上运行，为每个顶点设置顶点属性


**关于抽象 patch**：

primitive generation 阶段完全不需要关心顶点属性，它是工作在抽象 patch 上的。==**由 application 决定实际 patch 到抽象 patch 的映射**==。

例如：如果 patch 设置为 quad，那么 primitive generation 阶段看到的就是一个正方形

![[-最近/_attachments/Pasted image 20221106214517.png | 400]]



### TCS

每个 patch 对应一组 TCS，逐顶点执行。TCS 的职责就是控制细分的级别。

内建变量：

- `gl_InvocationID` ：可以知道当前 shader 在 patch 中的哪个顶点上执行的。
- `gl_TessLevelOuter[]` 和 `gl_TessLevelInner[]`：控制外部和内部镶嵌系数
- `gl_in[]` 和 `gl_out[]` ：数组长度等于 patch 中顶点的数量，元素类型如下：

```glsl
struct {
    vec4 gl_Position;           // 这是主要的部分
    float gl_PointSize;
    float gl_ClipDistance[];
};
```

TCS 的职责是：

- 写入 `gl_out[]` 
- 设置 `gl_TessLevelOuter[]` 和 `glTessLevelInner[]` 

如何控制细分级别，以四边形的 patch 为例：

- `gl_TessLevelInner[]` 是一个长度为 2 的数组，简单理解就是：第一个元素指定细分的列数，第二个元素指定细分的行数
- `gl_TessLevelOuter[]` 是一个长度为 4 的数组，主要控制 patch 边缘的细分级别，为了和其他的 patch 很好地拼接起来。


TCS 的例子：

```glsl
layout (vertices = 4) out;     // patch 是四边形

layout (location = 0) in vec2 in_uv[];     // 来自 vertex shader
layout (location = 0) out vec2 out_uv[];   // 输出给 TES

void main()
{
    // 不修改顶点属性，直接传递下去
    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
    out_uv[gl_InvocationID] = in_uv[gl_InvocationID];


    if (gl_InvocationID != 0) return;

    gl_TessLevelOuter[0] = 16.0;
    gl_TessLevelOuter[1] = 16.0;
    gl_TessLevelOuter[2] = 16.0;
    gl_TessLevelOuter[3] = 16.0;

    gl_TessLevelInner[0] = 16.0;
    gl_TessLevelInner[1] = 16.0;
}
```


### TES

TES 的职责是：根据插值系数（`gl_TessCoord`）为每个顶点设置合适的顶点属性。

内建变量：

- `gl_in[]` ：元素类型和 TCS 的一致。如果 patch 是 quad，那么 `gl_in[]` 的长度就 4，数据完全来源于 TCS。
- `gl_TessCoord` ：是一个 `vec2` ，表示当前顶点在抽象 patch 中的 uv 坐标。该 uv 坐标作为插值系数，根据 `gl_in[]` 得到当前顶点的顶点属性。



TES 的例子：

```glsl
#version 450

// pipeline 设置的背面剔除，且将背面设置为顺时针，因此这里生成的三角形是逆时针（正面）
layout (quads, fractional_odd_spacing, ccw) in;

layout (std140, set = 0, binding = 0) uniform UBO
{
    mat4 model;
    mat4 view;
    mat4 projection;
} ubo;

layout (set = 0, binding = 1) uniform sampler2D u_height_map;

layout (location = 0) in vec2 in_uv[];
layout (location = 0) out float out_height;

void main()
{
    float abstract_u = gl_TessCoord.x;
    float abstract_v = gl_TessCoord.y;


    // 双线性插值，得到顶点的 pos uv
    //     ---------> x, u
    //     | 0    1
    //     |
    //     | 2    3
    //     v z, v
    vec2 uv = mix(
        mix(in_uv[0], in_uv[1], abstract_u),
        mix(in_uv[2], in_uv[3], abstract_u),
        abstract_v);

    out_height = texture(u_height_map, uv).y * 64.0 - 16.0;


    vec4 pos = mix(
        mix(gl_in[0].gl_Position, gl_in[1].gl_Position, abstract_u),
        mix(gl_in[2].gl_Position, gl_in[3].gl_Position, abstract_u),
        abstract_v
    );


    // 计算 patch 的法线方向，直接是指向 y 方向的，和实际的地形无关
    vec3 normal = normalize(cross((gl_in[2].gl_Position - gl_in[0].gl_Position).xyz,
                                  (gl_in[1].gl_Position - gl_in[0].gl_Position).xyz));

    pos.xyz += normal * out_height;


    gl_Position = ubo.projection * ubo.view * ubo.model * pos;
}
```


### 参考
 
- [khronos - Tessellation](https://www.khronos.org/opengl/wiki/Tessellation)
- [LearnOpenGL - Rendering Terrain using Tessellation Shader](https://learnopengl.com/Guest-Articles/2021/Tessellation/Tessellation)
- [SaschaWillems - tessellation](https://github.com/SaschaWillems/Vulkan/blob/master/examples/tessellation/tessellation.cpp)
- [StackOverflow - How does tessellation know what vertices belong together in a face, when patch size > 4?](https://stackoverflow.com/questions/48302363/how-does-tessellation-know-what-vertices-belong-together-in-a-face-when-patch-s)


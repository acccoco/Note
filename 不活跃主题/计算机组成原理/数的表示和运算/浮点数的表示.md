

### IEEE 754 浮点数标准
![[不活跃主题/计算机组成原理/数的表示和运算/_attachments/1633870569162-55e7a6f0-3941-4bb5-ac7a-2b7a4f283000.png | 441]]

浮点数的表示：$N = r^E \times M$ ，其中：

- $r$  进制数，一般是 2
- $E$  是阶码，是有符号定点数，可以表示小数点的位置
- $M$  是尾数，是有符号定点数，表示浮点数的**精度**

其中：

- 数符表示正负
- 阶码使用移码表示：偏移为 $2^n - 1$ ，对于 `float` 来说，偏移为 `+127`。**这里的移码和补码并不是相差一个符号位了**。
- 尾数用原码表示。规格化后会将尾数变成 `1.xxx` 的形式，就是科学表示法的形式，最高位的 `1` 就不占用有效位数了。

单精度浮点和双精度浮点：

- `float`：阶码 8 位，尾数 23 位
- `double`：阶码 11 位，尾数 52 位

例子：`12` 用 `float` 表示为：

- $(12)_{10} = (1100)_2 = +1.1 \times 2^{3}$ 
- 正数，所以数符为 `0`；
- 阶码是 3，用移码表示为 `1000 0010` 
- 尾数是 1.1，隐去整数部分的 1，得到的结果是 `1000 ...` 
- 最终的浮点数为：`0 1000 0010 1000 0...` 

特别的：**阶码的取值范围为 **`**1~254**`

- 当阶码为 `0` ，且尾数全 0 时，表示 `0` 
- 当阶码全 `1`，且尾数全 0 时，表示无穷。 


### 规格化
为了尽可能利用浮点数的精度，要求**尾数的数值部分最高位必须是有效值**，也就是说：$\frac{1}{2} \le |M| \le 1$ 
如果计算结果不符合上述要求，就要进行规格化：移动尾数的小数点，并增减阶码

如果基数是 8，那么一定可以确保位数的数值部分最高的 3 位不全为 0，此时也是规格化的。

尾数可以用原码表示，也可以用补码表示。

- 原码表示时，最高位必须是 1
- 补码表示时，最高位与符号位不同

注：IEEE 754 已经隐去了最高位的 1。


### 溢出
![[不活跃主题/计算机组成原理/数的表示和运算/_attachments/1633870273562-dc87141a-49ee-4384-9d86-479036ba4885.png | 475]]

上溢是指浮点数的绝对值太大，阶码装不下
下溢是指浮点数的绝对值太小，即使阶码取最小值，仍然不能表示

注：**溢出都是阶码溢出**。


### 加法运算
对阶：计算之前应该让阶码相同，将小数的阶码对齐到大数的阶码，可能存在「大数吃小数」的情况

对阶之后对尾数求和即可。

**溢出判断**：通过阶码的符号位来判断是否溢出。使用双符号位的补码表示阶码，在规格化后，如果阶码的符号位为 `10`，表示下溢；阶码的符号位为 `01` ，表示上溢


### 浮点数的类型转换
`int` 转换为 `double` ：`int` 的位数是 32 位，`double` 的尾数是 52 位，因此转换不会丢失精度

`float` 转换为 `double` ：由于表示的值范围不同，可能发生「**溢出误差**」；由于精度不同，可能会发生「**舍入误差**」，导致小数丢失几位；

`float` 转换为 `int` ：可能会发生溢出误差；由于整形没法保持小数，还有可能发生「**截断误差**」。





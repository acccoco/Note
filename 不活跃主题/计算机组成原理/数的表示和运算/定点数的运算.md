
## 移位运算

### 逻辑移位运算
无符号数的移位运算就是逻辑移位运算。


### 算数移位运算
有符号数的移位运算就是算数移位运算。
移位运算时，**符号位不动**。

原码：左移和右移均补0
补码：左移补0，右移时补符号位
反码：正数左移和右移都是补0，负数左移和右移都是补1

注：**同一个负数，补码算数右移和原码算数右移得到的结果不同**。
例如，`[-7]补 = 1001`，`[-7]原 = 1111` ；补码算数右移一位得到 `1100 = [-4]补`，原码算数右移一位得到 `1011 = [-3]原`


## 加法运算
加法和减法都使用补码来进行。
一个小数加法的例子：（**虽然符号位有进位被丢掉，但并不存在溢出**）
![[不活跃主题/计算机组成原理/数的表示和运算/_attachments/1633004174668-73c7c934-47cc-4a69-8256-400e04f668be.png | 268]]


### 溢出判断
对于加法，只有「正数+正数」或者「负数+负数」才有可能会溢出。

**单符号位判断溢出**
做加法时，只要两个数符号位相同，结果的符号位与加数符号位不同，则溢出。

例如：（**这里并未舍弃任何进位，但确实溢出了**）
![[不活跃主题/计算机组成原理/数的表示和运算/_attachments/1633004522857-d010e2e9-c2a0-48cd-8e4f-f0b047701064.png | 237]]

符号位的进位和最高位的进位不同，则视为溢出。

**两个符号位判断是否溢出**
正数的符号位是 `00`，负数的符号位是 `11` 
运算结果两个符号位不同时，则发生溢出。


## 乘法运算
![[不活跃主题/计算机组成原理/数的表示和运算/_attachments/1632829209582-7ea28ec1-19fa-4e87-97f8-d2d1c1be73dd.png | 129]]

考察手算乘法可以发现，乘法运算由左移和累加构成
![[不活跃主题/计算机组成原理/数的表示和运算/_attachments/1633005183521-2d714065-12d1-457b-835c-159753e3cb05.png | 437]]


### 原码一位乘法

- 乘数和被乘数都用原码表示，符号位单独计算
- 最终结果需要借用 `y` 的存储空间，来存放低位，乘数部分 `y` 不需要符号位，乘积的部分高位取双符号位
- 根据乘数 `y` 的最后一位来决定下一步的操作

![[不活跃主题/计算机组成原理/数的表示和运算/_attachments/1633005904048-006df19e-aaa4-4663-8990-80bee1478f0c.png | 261]]


### 补码一位乘法

- 乘积的部分高位取双符号位，乘数/乘积的部分低位取单符号位，最后还有一个附加位，初始为0
- 根据乘数 `y` 的最后一位和附加位的值，决定当前的操作
   - `00` 和 `11`，只右移
   - `01`：加 `[x]补`，右移
   - `10`：加 `[-x]补`，右移
- 进行 `n + 1` 步，最后一步不用右移
- 结果为双符号位的补码
- 注：右移是算数右移

![[不活跃主题/计算机组成原理/数的表示和运算/_attachments/1633006410795-7569d268-a08f-4e1e-ba59-ffd127bb94bc.png | 316]]


## 除法运算
除法运算可以转化为「累加-左移」操作
![[不活跃主题/计算机组成原理/数的表示和运算/_attachments/1632829225188-b06bc59e-1f89-4892-9efc-e6cbe995ee0b.png | 119]]


### 原码除法运算
原码加减交替法，余数始终是正数，不需要恢复余数
> 还有一种原码的恢复余数除法，余数有可能是负数，此时需要加上除数，让余数变为正数。



## 哪些运算会溢出
加法运算：

- 符号不同时得到的结果一定不会溢出
- 符号不同时得到的结果可能会溢出

乘法运算：

- 结果的高位和低位是分开保存的

除法运算：

- 不会溢出

缓存可以参考这篇文章：
[linux 内存值 cache](https://blog.csdn.net/wyttRain/article/details/110925923)


## 缓存工作的基本原理
「Cache - 主存」的存储体系，利用了程序执行的「局部性」原理，可以加快 CPU 访问**物理内存**的速度。

**Cache 的基本单位**：内存被划分为「块」，缓存被划分为「行」，两者大小相等，是基本单位。
注：CPU 和 Cache 之间数据交换的基本单位是「**字**」。
![[不活跃主题/计算机组成原理/存储器/_attachments/1634388561889-7cbde412-a17c-40f6-8ba8-75e153d28890.png | 495]]


## Cache 的映射方式

### 直接映射
主存的每一块都对应着唯一一行缓存：
![[不活跃主题/计算机组成原理/存储器/_attachments/1634388884387-db3a7d38-ac45-471e-955d-9e2b08afd029.png | 353]]

主存的地址可以进行如下划分：

- 块内地址：共 $k$  位，满足块的大小为 $2^k$  
- Cache 的行号：共 $m$  位，满足 Cache 共有 $2^m$  行
- 标记：用于在找到对应行的缓存后，和其中的标记进行比较，判断是否命中（通过这个标记区分对应着同一个 Cache 行的多个主存块）

![[不活跃主题/计算机组成原理/存储器/_attachments/1634389085211-4d7587aa-319e-4bfc-a65b-acc9d8b6a873.png | 493]]


### 全相联映射
主存中的任意一块都可以放入缓存中的任意一个位置：
![[不活跃主题/计算机组成原理/存储器/_attachments/1634389474800-34f37545-ae5e-44db-83f4-0511d29a4d35.png | 169]]

在进行 Cache 查找时，需要查找每一个缓存行。

主存的地址结构为：
![[不活跃主题/计算机组成原理/存储器/_attachments/1634389727357-078ade37-dde1-42ad-8861-cd8776f1b8eb.png | 443]]


### 组相联映射
将 Cache 的多个行划分为一个组，主存的每一个块都和具体的某个组对应，组内进行全相联映射：
![[不活跃主题/计算机组成原理/存储器/_attachments/1634389977948-d145648b-3efd-4fef-b83a-988cb9034e21.png | 358]]

**路数**：表示一个 Cache 组中有多少个行

主存的地址划分为：
![[不活跃主题/计算机组成原理/存储器/_attachments/1634390012971-83aa7c88-160b-4a6b-ace8-a52684c8780d.png | 455]]


## 缓存替换算法
什么情形需要进行缓存替换：在 Cache 的一个组中，内容已满，还想要读入新的行，此时需要淘汰掉一个行。


### LRU
LRU 如何进行：为每一个缓存行设置一个计数器，用于表示该行的新旧程度。每次淘汰掉最不常用的一行，访问一行后会更新其计数器的值。

手工的算法如下：

- 假设访问内存的顺序为：`A B C D B E`，共有 4 个缓存行
- 图中：越靠近下方，表示越常使用。

![[不活跃主题/计算机组成原理/存储器/_attachments/1634390956650-616b7215-a243-44b9-ad7b-8736022c24f3.png | 459]]


## 缓存写回策略
缓存命中时：

- 「全写法」：更新 Cache 的同时，还需要将「主存」也更新；进行替换时不需要额外的操作
- 「写回法」：只更新 Cache，不更新「主存」；Cache 的对应行会表标记为「脏」，在进行替换时才将内容更新到「主存」。

缓存不命中时：

- 「写分配法」：从「主存」读入到 Cache，然后更新 Cache 中的内容；
- 「非写分配法」：直接把内容更新到「主存」，不会将块调入 Cache；

可以看出：

- 「全写法」和「写分配法」是比较「Lazy」的策略，这两者通常配合起来使用。
- 相应的，「写回法」和「非写分配法」通常配合起来使用。




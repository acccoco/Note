
### 函数调用的过程
函数调用需要做的事情：

|              | **主调函数**                                    | **被调函数**                                                             |
| ------------ | ----------------------------------------------- | ------------------------------------------------------------------------ |
| **函数调用** | 1. 传递参数2. 保存返回地址3. 跳转到「被调函数」 | 1. 保存「主调函数」的寄存器2. 为「局部变量」分配空间                     |
| **函数返回** |                                                 | 1. 恢复「主调函数」的寄存器，释放「局部变量」的空间2. 返回到「主调函数」 |


保存返回地址和跳转到「被调函数」由 `call` 实现，`call` 指令的作用：

- 将下一条指令的地址放入栈中，跳转到被调函数中
- 相当于先后执行：`push PC`，`jmp <function>`

返回到「主调函数」由 `ret` 实现，`ret` 指令的作用：

- 从栈中取出返回地址，跳转到该返回地址
- 相当于先后执行：`pop <temp>`，`jmp <temp>`

恢复「主调函数」的寄存器和释放「局部变量」的空间可以由 `leave` 指令实现：

- 也可以不使用 `leave`，用代码组合实现：`movl %ebp, %esp` ，`popl %ebp`


### 例子
以 「cdcel」这种调用约定为例：

- 参数传递：从右至左的顺序放入栈中
- 返回值：通过 `eax` 寄存器返回
- 易失寄存器：`eax, ecx, edx`，非易失寄存器：主要是 `esp, ebp, edi`
> 易失寄存器是由「主调函数」维护的；非易失寄存器是由「被调函数」维护的


**C 语言的代码为**：
```c
int add(int x, int y) {
    return x + y;
}

int caller() {
    int temp1 = 125;
    int temp2 = 80;
    int sum = add(temp1, temp2);
    return sum;
}
```

**对应的汇编代码为**：
```c
caller:
  # 保存「call 的主调函数」的寄存器，为「局部变量」分配空间
  pushl		%ebp
  movl		%esp, %ebp
  subl  	$24, %esp
  # 将自己的临时变量放入栈中
  movl 		$125, -12(%ebp)		# temp1
  movl		$80,  -8(%ebp)		# temp2
  # 为「被调函数 add」传递参数
  movl		-8(%ebp), %eax		# y = temp2
  movl		%eax, 4(%esp)
  movl 		-12(%ebp), %eax		# x = temp1
  movl		%eax, (%esp)
  # 调用 add
  call  	add
  # 将临时变量放入栈中
  movl		%eax, -4(%ebp)		# sum = add(...)
  # 将返回值放入 eax
  movl		-4(%ebp), %eax
  # 返回
  leave 
  ret
 
add:
  # 保存「caller」的现场
  push		%ebp
  mov 		%esp, %ebp
  # 取出参数
  mov		0xc(%ebp), %eax
  mov		0x8(%ebp), %edx
  # 执行计算
  lea		(%edx, %eax, 1), %eax
  # 返回
  pop		%ebp
  ret
```

**对应的 stack frame 为**：
![[不活跃主题/计算机组成原理/程序结构的汇编表示/_attachments/1634649274117-0cdb8f54-40da-4851-b820-9179b62d279b.png | 882]]

注：为什么「caller 的 stack frame」中有 4Byte 空间未使用？

- 因为 GCC 规定 stack frame 的大小需要是 16 Byte 的整数倍


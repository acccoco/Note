
## 控制单元的结构
控制单元的作用就是发出一系列的「微操作命令」

控制单元的外特性：

- 接受输入：译码器产生的「指令信息」，节拍发生器的「节拍信息」，执行单元的反馈「标志」。除此之外，还有「系统总线的控制信号」。
- 输出控制信号给「CPU内」以及 CPU 外，也就是「系统总线」

![[不活跃主题/计算机组成原理/中央处理器/_attachments/1634902132459-43de3c0c-ca65-4be2-af77-1b4608fb7da5.png | 296]]


## 微操作
一个「机器指令」可以分解为多个「微操作」。

例如，**取指周期**可以分解为多个微操作：

1. `PC -> MAR`
2. `1 -> R`：向主存发送读命令
3. `M(MAR) -> MDR`：主存向 MDR 发送数据
4. `MDR -> IR` 
5. `OP(IR) -> CU`：将指令的操作码发送到控制单元进行「译码」
6. `(PC) + 1 -> PC`：形成下一条指令的地址

![[不活跃主题/计算机组成原理/中央处理器/_attachments/1634894112237-7f9ed9ac-2324-421a-95cc-f31e855568fa.png | 358]]


## 控制单元的实现
控制单元有两种实现方式：

- 「硬布线」设计，通过组合逻辑电路实现。线路庞杂，但是速度很快。
- 「微程序」设计。设计相对简单，由于存在访问「控制存储器」的操作，速度相对较慢。

> 关于硬布线和微程序的类比：
> - 硬布线相当于全用 `if-else` 实现程序逻辑
> - 微程序相当于用「查表法」实现程序逻辑


一般来说，「**复杂指令集机 CISC**」使用微程序控制器，而「**精简指令集机 RISC**」使用硬布线控制器。


## 硬布线控制单元
组合逻辑的设计就是：得出每种微操作的执行条件。例如什么阶段（取指，间址，执行）；什么机器指令（`ADD, JMP, LDA`）；什么节拍


### 微操作的节拍安排
对于每个指令，分析所有的微操作，将不同的微操作安排在合适的节拍来进行。

- 假定每个机器周期包含三个节拍，$T_0, T_1, T_2$ ；
- 在保证一定的先后次序的情况下，尽量将不同的微操作安排到一个节拍中执行，以节省时间。

**以「取指周期」的微操作为例**：
每个指令的取指操作都是相同的，有以下几个「微操作」：

| **微操作**       | **说明**                                 |
| ---------------- | ---------------------------------------- |
| `PC -> MAR`      |                                          |
| `1 -> R`         | 向主存发送读命令                         |
| `M(MAR) -> MDR`  | 主存向 MDR 发送数据                      |
| `MDR -> IR`      |                                          |
| `OP(IR) -> CU`   | 将指令的操作码发送到控制单元进行「译码」 |
| `(PC) + 1 -> PC` | 形成下一条指令的地址                     |


上述的微操作当然可以顺序执行，但是有些操作可以并行执行，节省时间：

| **节拍** | **微操作**                        | **说明**                                                         |
| -------- | --------------------------------- | ---------------------------------------------------------------- |
| **T0**   | `PC -> MAR`，`1 -> R`             |                                                                  |
| **T1**   | `M(MAR) -> MDR`，`(PC) + 1 -> PC` |                                                                  |
| **T2**   | `MDR -> IR`，`OP(IR) -> CU`       | 考虑到译码的时间较短，可以将这两个有先后次序的操作安排在一个节拍 |


如下图所示：
![[不活跃主题/计算机组成原理/中央处理器/_attachments/1634895778990-dd96788e-9370-44ea-ac05-0ca65ce83618.png | 354]]


### 操作时间表
分析一系列指令的微操作节拍安排，得到「操作时间表」：

- 其中 `FE, IND, EX` 表示 CPU 工作周期标志，取指，间址，执行
- `I` 为间址标志，表示是否需要间接寻址。在取指阶段的 T2 节拍，如果出现间址标志，则进入「间址周期」，否则进入「执行周期」。
- 如果在间址周期的 T2 时刻，测得 `IND = 1`，则表示多次间址，继续执行间址周期；否则 `EX` 触发器置为 1，进入执行周期。
- 对于一个「机器指令」，在一个节拍中的一系列「微操作」可以**并行执行**。

![[不活跃主题/计算机组成原理/中央处理器/_attachments/1634888982181-0775c9cb-c10d-495c-8e7c-6696685e69b2.png | 585]]


### 微操作命令的逻辑实现
根据上述的「操作时间表」，可以得到每个「微操作」执行的**逻辑条件**。
例如：`M(MAR) -> MDR` 这个微操作：

- 在取指周期，每个指令都会执行，执行时刻为 T1
- 在间址周期，`ADD, STA, LDA, JMP, BAN` 指令会执行，执行时刻为 T1
- 在执行周期，只有 `ADD, LDA` 指令会执行，时刻为 T1

因此可以写出以下逻辑表达式：
$$\begin{array}{lll}

 M(MAR) \to MDR \\
= FE \cdot T_1 + IND \cdot T_1 (ADD + STA + LDA + JMP + BAN) + EX \cdot T_1 (ADD + LDA)\\
= T_1\{ FE + IND (ADD + STA + LDA + JMP + BAN) + EX(ADD + LDA) \}
\end{array}$$

根据逻辑表达式，可以得到「微操作」`M(MAR) -> MDR` 对应的**逻辑图**：
![[不活跃主题/计算机组成原理/中央处理器/_attachments/1634889782117-5e70aaf2-9e07-4239-ae8e-a8ee11d3749a.png | 497]]


## 微程序控制单元
**微程序的核心思想是**：通过一个「微程序」来实现一条「机器指令」；

- 每个「微程序」由多个「微指令」构成；
- 每个「微指令」对应一个或多个可并行执行的「微操作命令」；


### 微程序的存储
微程序存储在「控制存储器」中，它是微程序控制单元的核心部件，由 **ROM** 构成。
每一条「微指令」由两部分构成：

- 第一部分对应着一系列的微操作命令。最简单的情形是，每一位对应一个微操作命令。
- 第二部分表示下一条「微指令」的地址

注意到，`LDA, ADD, STA, JMP` 等机器指令对应的「微程序」的最后一条「微指令」，其「下地址」都指向「取指周期微程序」的首地址。
![[不活跃主题/计算机组成原理/中央处理器/_attachments/1634890984508-6f923b2e-0b1c-437d-8874-61aa13f9aea1.png | 262]]

一条机器指令对应一个「微程序」，每个机器的「取指周期」都是相同的，因此可以独立出一个「取指周期微程序」。


### 微程序控制单元的结构
![[不活跃主题/计算机组成原理/中央处理器/_attachments/1634890787832-4c76a84a-f364-41da-b0d3-20a78f564249.png | 341]]

其中：

- CMAR 是「微地址寄存器」，用于存放「微指令」在「控制存储器」中的地址
- CMDR 是「微指令寄存器」，用于存放当前执行的「微指令」

这个结构如何动起来：

- 在执行一个「微程序」时，每执行完一条「微指令」，如果其存在「下地址」，那么可能会继续执行下地址对应的「微指令」。
- 最开始的时候，「取指周期微程序」的首地址会被自动送到「微地址形成部件」中。
- 「取指周期微程序」执行完后，机器指令的操作码会被送到「微地址形成部件」，从而得到机器指令对应的「微程序」的首地址。
- 一般来说，一个「微程序」的最后一个「微指令」，其「下地址」指向「取指周期微程序」。因此在执行完一条「机器指令」后，会自动执行「取指周期」

![[不活跃主题/计算机组成原理/中央处理器/_attachments/1634892119526-eea6b9d9-4a6e-4f40-a33b-00626a11a874.png | 200]]


### 微指令的编码
**直接编码**：每一位表示一个「微操作命令」。这种编码方式，会让「微指令」的长度非常长
**字段直接编码**：将「微操作命令」分为多个组，组内的各个各个微操作是互斥的，因此一组内的 $n$  个微操作命令只需要 $\log_2 n$  位即可。通常一组内会用全零的编码表示该组没有微操作。
![[不活跃主题/计算机组成原理/中央处理器/_attachments/1634893140228-47430a10-dbd2-4592-b9ce-2c8c2bd24449.png | 543]]

**例如**：如果某机器的微操作命令可以分为 5 组，每组的微操作命令分别为 5，8，3，16，1 个，那么微指令的操作控制字段所需的位数为：

- 直接编码：$5+8+3+16+1 = 33$ 
- 字段直接编码：$3 + 4 + 2 + 5 + 1 = 15$  

**微指令的格式**：

- 水平型微指令：一条水平型微指令可以表示**几条并行**执行的「微操作命令」。每条「微指令」很长，「微程序」很短。
- 垂直性微指令：一条垂直型微指令只能表示**一条**「微操作命令」。每条「微指令」很短，「微程序」较长，容易编写。


### 微程序的设计
首先得到为操作的节拍安排，以「**取指阶段**」为例：

| **节拍** | **微操作**                              | **说明** |
| -------- | --------------------------------------- | -------- |
| **T0**   | `PC -> MAR`，`1 -> R`                   |          |
| **T1**   | `M(MAR) -> MDR`，`(PC + 1) -> PC`       |          |
| **T2**   | `MDR -> IR`，`OP(IR) -> 微地址形成部件` |          |


由于微指令也需要从「控制存储器」中取出，因此得到以下的微指令：

| **节拍** | **微指令的内容**                        | **说明**                                                         |
| -------- | --------------------------------------- | ---------------------------------------------------------------- |
| **T0**   | `PC -> MAR`，`1 -> R`                   |                                                                  |
| **T1**   | `Ad(CMDR) -> CMAR`                      | 从「微指令寄存器」中取出微指令的「下地址」，放入「微地址寄存器」 |
| **T2**   | `M(MAR) -> MDR`，`(PC + 1) -> PC`       |                                                                  |
| **T3**   | `Ad(CMDR) -> CMAR`                      |                                                                  |
| **T4**   | `MDR -> IR`，`OP(IR) -> 微地址形成部件` |                                                                  |
| **T5**   | `OP(IR) -> 微地址形成部件 -> CMAR`      |                                                                  |





依靠的性质：两点之间的最短路径，包含了路径上其他顶点之间的最短路径。

对于非带权图，可以利用广度优先搜索 BFS 来得到单源最短路径。


### 单源最短路径：Dijkstra算法（贪婪）

###### 辅助数据结构：

- `solved[]`：标记一个顶点是否已经被解决
- `distance[]`：表示从源点到某一点的最短路径长度。每当找到一个新的节点的最短路径的适合，就更新这个数据结构。
- `**path[]**`：结点在最短路径上的前趋结点，类似于树的双亲表示法

![[不活跃主题/数据结构与算法/图/_attachments/1631274301315-53bedca0-8be4-4f2a-9b1d-0d341133385d.png | 605]]

「Prim算法」和「Dijkstra算法」的比较：

- 在「Prim算法」中，`distance[]` 中存放的是从生成树到某个结点的最短边长
- 在「Dijkstra算法」中，`distance[]` 中存放的是从源点到结点的最短路径长度

**局限性**：当图中具有**负权值**的边时，「Dijkstra算法」失效。

注：**单源最短路径得到的生成树并不一定是最小生成树**。


### 多源最短路径：Floyd算法
本质是 DP
每次迭代的时候，多考虑一个顶点进去。
迭代过程如下：

$$A^{(-1)}[i][j]=arcs[i][j]$$
$$A^{(k)}[i][j]=Min\left\{\begin{array}{lll}A^{(k-1)},\\ A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\end{array}\right.$$

其中：

- $A^{(-1)}[i][j]$  表示从 $v_i$  到 $v_j$  的直接距离
- $A^{(0)}[i][j]$  表示考虑中间顶点 $v_0$  后，$v_i$  到 $v_j$  的距离

局限性：可以处理带负权值的图；**不允许带负权值的边组成回路**。

如何理解 Floyd 算法：

- $A^{(k)}[i][j]$  表示利用了 $1 \cdots k$  节点后 $i,\ j$  节点之间的最短距离。
- 转移方程就是上面的方程。


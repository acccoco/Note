## <span style="color:blue;">🌲树状数组</span>

树状数组擅长<span style="background:yellow;">单点修改，区间查询</span>

#### <b style="color:darkblue;">🌿 树状数组的结构</b>

在原数组`A[n]`的基础上构建一个辅助数组，记作`C[n]`。<b style="color: red">注意：下标从1开始。</b>

##### 🍃 <b style="color: red">lowBit</b>

- 它表示：一个数用二进制表示时，最低位的1所表示的值。
- 另一重含义：它表示一个数的最大因数，这个因数必须是**2的k次幂**。
- 计算`lowBit`的方法：`lowBit = i&(-i)`。原理：补码，取反加一。
- 比如：
    - 24：二进制表示为`11000`，`lowBit = 8`。
    - 12：二进制表示为`1100`，`lowBit = 4`。



![[不活跃主题/数据结构与算法/查找/_attachments/Pasted image 20221101022227.png]]



##### 🍃 `C[i]`的含义

- `C[i]`表示：数组`A[n]`中，包括`A[i]`在内的前方`lowBit`个元素的总和。

$$
C[i] = \sum_{t=0}^{lowBit}A[i-t]
$$

- `C[i]`还可以使用数组`C[n]`中的其他元素来表示：
    - 对于`i`来说：$2^k = lowBit$；`i`的二进制表示中，末尾有`k`个0；`C[i]`表示`A[n]`中$2^k$个元素的和；
    - 当$t<k$时，对于$i-2^t$，它的末尾有`t`个0；那么$C[i-2^t]$表示`A[n]`中$2^t$个元素的和；
    - $2^k$可以写成$2^k=1+\sum_{t=0}^{k-1}2^t$，所以`C[i]`可以用其他的`C[n]`表示为：

$$
C[i] = A[i] + \sum_{t=0}^{k - 1}C[i-2^t]，其中2^k=lowBit
$$



##### 🍃 父子结点

- `C[i]`的父节点是`C[i+lowBit]`。
- `C[i]`的子节点共有`k + 1`个，其中$2^k = lowBit$。



#### <b style="color:darkblue;">🌿 树状数组的操作</b>

##### 🍃 构造$O(nlogn)$

通过`C[i]`的子节点来构造`C[i]`，复杂度是$O(nlogn)$。

```cpp
void Init(vector<int> A, vector<int> C) {
	for (int i = 1; i < A.size(); ++i) {
    	int lowBit = i & (-i);
        C[i] = A[i];
        for (int pf = 1; pf < lowBit; pf <<= 1) {
        	C[i] += C[i - pf];
        }
    }
}
```

##### 🍃 单点查询$O(1)$

直接查询`A[n]`即可，所以复杂度为$O(1)$。

##### 🍃 区间查询$O(logn)$

```cpp
// 计算区间和，闭区间C[a, b]
int IntervalSum(vector<int> C, int a, int b) { 
	return PrefixSum(C, b) - PrefixSum(C, a - 1);
}
// 计算前缀和，闭区间A[1, m]
int PrefixSum(vector<int> C, int m) {
	int sum = 0;
    while (m > 0) {
    	sum += C[m];
        m -= (m & (-m));
    }
    return sum;
}
```

##### 🍃 单点修改$O(logn)$

找到所有的祖先结点即可，复杂度为$O(logn)$。

```cpp
void Update(vector<int>& A, vector<int>& C, int index, int value) {
    int delta = value - A[index];
    A[index] = value;
    // 受影响的结点都增加delta即可
    while (index < c.size()) {
    	c[index] += delta;
        index += (i & (-i));	// 定位到父节点
    }
}
```

##### 🍃 区间修改x

并不擅长

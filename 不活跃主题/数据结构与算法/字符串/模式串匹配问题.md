## <b style="color:red;">正则表达式匹配</b>

#### <span style="color:#0202c0;">题目</span>

```
判断模式字符串p是否能匹配字符串s
模式字符串包含以下
	'.' 匹配任意单个字符
	'*' 匹配零个或多个前面的那一个元素
输入:
	s = "aab"
	p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```

#### <span style="color:#0202c0;">解题</span>

​	<b style="color:red;">有回溯</b>：由于`x*`合起来可以表示0个或多个`x`字符，所以`*`字符可以取消前一个字符的匹配，这就有了回溯。

​	模式串`p[0...i]`是否能够匹配字符串`s[0...i]`？可以从`p[0...i-1]`的匹配情况判断：

![[不活跃主题/数据结构与算法/字符串/_attachments/Pasted image 20221101021143.png]]

设计`dp[i][j]`表示模式串`p[0...i]`是否能够匹配字符串`s[0...j]`



![[不活跃主题/数据结构与算法/字符串/_attachments/Pasted image 20221101021217.png]]



## <b style="color:red;">通配符匹配</b>

#### <span style="color:#0202c0;">题目描述</span>

```
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。
	'?' 可以匹配任何单个字符。
	'*' 可以匹配任意字符串（包括空字符串）。
说明:
    s 可能为空，且只包含从 a-z 的小写字母。
	p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。
```

#### <span style="color:#0202c0;">解题</span>

##### 最优子结构

`p[0...i]`要能够匹配`s[0...j]`：

- 如果`p[i]`是`'?'` , 那么必有 `dp[i - 1][j - 1] == 1`

- 如果 `p[i]` 是一般字符, 且`p[i] == s[j]`，那么必有 `dp[i - 1][j - 1] == 1`

- 如果` p[i]` 是 `'*'`, 那么：
    - `*`表示0个字符，必有 `dp[i - 1][j] == 1`
    - `*`表示1个字符，必有 `dp[i - 1][j - 1] == 1`
    - `*`表示多于1个字符，必有 `dp[i][j - 1] == 1`

##### 空间优化：

只需要两行即可：第`i`行和第`i-1`行；在每次循环时<b style="background:yellow;">交换指针</b>即可。

##### 初始化的优化：

初始化第一列时十分不方便，可以多增加一列：`dp[i][-1]`，表示模式`p[0...i]`能够匹配空字符串，只有模式串全部为`'*'`时才能匹配成功。


![[不活跃主题/数据结构与算法/字符串/_attachments/Pasted image 20221101021229.png]]


[[不活跃主题/数据结构与算法/字符串/_attachments/通配符匹配.cpp]]


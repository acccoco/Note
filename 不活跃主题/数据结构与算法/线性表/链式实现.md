
## 1. 单链表

### 头节点
一般通过**头指针**来表示一个链表
在链表的头部增加一个**头节点**，头节点不存储数据
![[不活跃主题/数据结构与算法/线性表/_attachments/1629546971148-cfa1d14f-76ce-4806-a3dc-f4f87791f44a.png | 327]]

```cpp
/* 链表节点的定义 */
struct Node {
	int val = 0;
    Node *next = nullptr;
};

/* 使用头指针来表示一个链表 */
typedef Node *LinkList;
LinkList list1 = new Node(); 	// 这里创建了一个空的头节点
```

**使用头节点的好处**：

- 可以统一空链表和非空链表的处理
- 可以统一头节点和一般节点的处理

**在头部插入节点时，使用头节点和不使用头节点的区别**：
注意到：

- 不使用头节点时，操作有些**怪异**
- 不使用头节点时，需要传**头指针的引用**进去（我更希望保持头指针不变）
```cpp
/* 使用头节点 */
void insert(LinkList list, int value) {
	Node *node = new Node();
    node->val = value;
    node->next = list->next;
    list->next = node;
}

/* 不使用头节点 */
void insert(LinkList &list, int value) {
	Node *node = new Node();
    node->value = value;
    node->next = list;		// 这两句感觉挺怪的
    list = node;
}
```


### 前插操作
已知单链表的一个节点，想要在该节点之前插入另一个节点

**方法1: 找到前驱节点**
从链表头部开始，找到该节点的前驱节点，然后将元素插入到前驱节点的后面，时间复杂度为：$O(n)$ 
![[不活跃主题/数据结构与算法/线性表/_attachments/1629547274504-143d2acf-028f-474b-a9a5-ffe70b1acef4.png | 256]]

**方法2: 在后方插入，并交换内容 **
将元素插入到该节点的后面，然后调换两个节点的值，时间复杂度为：$O(1)$ 
![[不活跃主题/数据结构与算法/线性表/_attachments/1629547284116-70719cbd-00fb-479b-9dae-d5a8506d7a45.png | 247]]


### 删除操作
已知某个节点 `*p`，想要删除这个节点。
和前插类似，也有两种方法

**方法1**: 找到这个节点的前驱节点，然后执行删除操作，时间复杂度：$O(n)$ 

**方法2**: 将后继节点的值赋值给当前节点，然后删除后继节点，时间复杂度为：$O(1)$ 

注：如果要删除的节点是最后一个节点，由于需要将前驱节点的 `next` 置为 `NULL`，时间复杂度只能是：$O(n)$ 


## 2. 双链表
双链表也可以有头节点，同样可以简化操作
![[不活跃主题/数据结构与算法/线性表/_attachments/1629547871619-4563768b-3eda-4faa-ae10-8b272de41d70.png | 347]]


## 3. 循环单链表
使用头节点的循环单链表情形：
![[不活跃主题/数据结构与算法/线性表/_attachments/1629548389456-7eac4556-868e-4699-b383-b508f5ddec9e.png | 302]]

**使用尾指针的好处**：
由于是单链表，如果使用头指针，那么在尾部插入的时间复杂度就是$O(n)$ ；使用尾指针可以让头部插入和尾部插入的时间复杂度都是$O(1)$ 

**判断循环单链表是否空**：头节点的后继是否是头节点


## 4. 循环双链表
。。。


## 5. 静态链表
借助**数组**来描述链表的**静态结构**：
![[不活跃主题/数据结构与算法/线性表/_attachments/1629548789805-f3709b1a-4454-4939-b091-d66ec1c6c362.png | 224]]

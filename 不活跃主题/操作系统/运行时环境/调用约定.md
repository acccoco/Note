
### 调用约定
函数调用约定是一种`ABI`，即程序二进制接口 _Application Binary Interface_ 。
函数调用约定主要规定这些方面（参考 _Wikipedia_ ）：

- **参数，返回值存放在何处**（寄存器还是调用堆栈，或者其他位置）
- **形参和实参的传递顺序**
- **非易失寄存器**：被调用者必须为调用者保留哪些寄存器
- **清理**：函数调用之后，调用者和被调用者各需要执行什么样的清理任务（比如清理栈里的参数）
- **名称修饰**：代码中的符号名称如何映射到链接器中的符号名称


##### 函数调用的一般结构（参考 wikipedia）
```assembly
func:
  push EBP            ; 保存旧的栈指针
  mov EBP,ESP         ; 取得新的栈指针
  sub ESP,localsize   ; 为局部变量保留栈空间
  .
  .                   ; 进行计算，将返回值放在eax中
  .
  mov ESP,EBP         ; 释放为局部变量保存的栈空间
  pop EBP             ; 恢复旧的栈指针
  ret paramsize       ; 释放参数的栈空间，并返回
```
`ebp`寄存器是非易失的寄存器，函数在开始时将`ebp`保存在栈中，在结束时从栈中恢复`ebp`
在函数运行期间，从`ebp`到`esp`的空间，就是**局部变量**使用的空间
![[不活跃主题/操作系统/运行时环境/_attachments/1600093572407-6211ec15-1c23-4059-85e4-d5911bd483ec.png | 257]]
接下来介绍几种常见的函数调用约定


### 常见的调用约定

#### 1. cdcel
_cdcel_ ，_C Declaration_ ，是一个源于 _C_ 语言的函数调用约定。
参数传递：从右向左的顺序放入栈中
返回值：整型和指针通过`eax`寄存器返回，浮点数通过`STO x87`寄存器返回
易失寄存器：`eax, ecx, edx`；非易失寄存器：其他的寄存器
清理：由调用者来清理栈
> 什么是易失寄存器和非易失寄存器：
> 易失寄存器 _caller-saved_ ：在进行`call`之后，这些寄存器中的值可能会改变，所以需要调用者自己来保护，比如将这些就寄存器中的值压入栈中。
> 非易失寄存器 _callee-saved_ ：在进行`call`之后，这些寄存器中的值不会发生改变。对于被调用者来说，应该保护这些寄存器中的值，比如不去使用这些寄存器，或是在使用前进行保存和使用进行恢复。



#### 2. stdcall
参数传递：从右向左放入栈中
易失寄存器与非易失寄存器：同 _cdcel_
返回值：同 _cdcel_ ，通过`eax`传递
清理：被调用者负责清理栈
应用：是 _Microsoft Win32 API_ 的调用约定


##### 3. thiscall
这个调用约定用于 _C++_ 的非静态类成员函数。
该调用约定可以处理`this`指针。例如，在 _GCC_ 中，`this`指针被视为第一个参数，通常最后一个被压入栈中；在 _Microsoft VC++_ 编译器中，`this`指针会被放入`ecx`寄存器中。

##### 4. x86-64
这项调用约定并不和 _stdcall, thiscall, cdecl_ 等独立，而是这些调用约定的一个**补充**，当编译目标是 _64位程序_ 时，这项额外的调用约定就会启动
作用：编译器会使用一些**寄存器**来传递头几个参数
如何使用：

- 想要在 _Visual Studio_ 中使用这种调用约定，只需要设置平台为 _x64_ 即可
- 使用 _GCC_ 编译时，如果宿主机是64位的，那么默认使用 _64位_ 的调用约定

##### 名称修饰
名称修饰的问题比较复杂：不同的调用约定（ _cdecl_ 和 _stdcall_ ），不同的语言（ _C_ 和 _C++_ ），不同的平台（ _x86_ 和 _x64_ ），不同的编译器（ _vc_ 和 _gcc_ ）都会对名称修饰产生影响。这里不进行详细研究。
一般来说， _C_ 程序由于不涉及重载，所以不需要名称修饰。
一般情况下，一个函数的调用和返回过程可以总结为以下过程：

#### 函数调用和返回

##### 函数调用

- 主调函数
   - 将参数放入栈中
   - 将返回地址放入栈中，然后跳转到被调函数。（这个步骤由单个指令 `call` 来完成）
- 被调函数
   - 将主调函数的帧指针存放在栈中
   - 从当前的栈顶生成新的帧指针，放入`ebp`中
   - 分配一定的栈空间，用于存放局部变量和临时变量

##### 函数返回

- 被调函数
   - 使用`eax`存放返回结果（如果有的话）
   - 从栈中取出主调函数的帧指针，放入`ebp`中
   - 清理栈空间
- 主调函数
   - 清理栈空间

#### Linux 环境下的函数调用

##### 1. 默认的`cdecl`调用约定
注：使用`gcc -m32`，因为 _x64_ 情况下会使用寄存器来传递参数。（如果选项不成功，那么需要安装一些依赖包`build-essential module-assistant gcc-multilib g++-multilib`）
![[不活跃主题/操作系统/运行时环境/_attachments/1600093572470-ddf2fc69-2f1b-4856-bdeb-717242a0e7da.png | 982]]
上述例子中，局部变量的空间如下：
![[不活跃主题/操作系统/运行时环境/_attachments/1600093572506-01dc68c6-775c-4207-a146-eab2a3b9ca58.png | 350]]
> **有一个疑问**
> 为什么为局部变量分配`0x10`的内存空间，这个空间并没有完全使用。是因为要`16bytes`对齐吗？


##### 2. `stdcall`调用约定

#### windows下的函数调用
cdecl
stdcall

#### 补充：指令与寄存器

##### `linux`指令和寄存器解释
`rbp`寄存器是一个64位寄存器，`bp`表示`base pointer`。

##### `lea`命令
取地址，并放入目的寄存器中。
和`mov`的区别在于：`lea`是取地址，而`mov`是取内容
例子：
```assembly
# 8086
# SI = 1000H, DS = 5000H, [51000H] = 1234H
LEA BX, [SI]	# BX = 1000H
MOV BX, [SI]	# BX = 1234H
```
`lea`指令可以用于得到数组某元素的地址，如：
```assembly
# 8086
LEA BX, 6[DI]
```

##### `call`与`ret`
`call`会将下一条要执行指令的地址压入栈中，然后进行跳转。
`ret`会从栈中取出地址放入`EIP`，然后继续执行。

**待整理**
> 以下是Linux2.4的调度策略，时间复杂度是O(n)

- 首先需要了解`调度周期`这个概念
   - 在每个周期开始时为进程分配时间片
   - 所有就绪进程的时间片都用完时周期结束
   - 在一个周期中可以发生多次调度，如：进程状态转换，时间片用光，中断之后等
- 对于普通进程，调度程序根据进程的权重来调度进程使用处理器，在`goodness()`函数中
   - `weight = k * [counter + (20 - nice)]`
   - 其中，`counter`表示进程的`剩余时间片`，又叫`动态优先级`；`nice`是`静态优先级`，用户可以修改。
- 在每个调度周期开始时，按照下面的方法分配时间片
   - `counter = (counter>>1) + [k * (20 - nice) + 1]`
   - 如果一个进程在上一个周期未用完时间片，那么剩余时间片会折半累加在新的时间片上。对于IO密集型，这样做可以提高优先级。
   - 如果一个进程在上一个周期用完时间片，那么这个周期分配到的是初值。
   - `静态优先级`可以影响到时间片的长短。
- 对于`实时进程`，他们的权重远大于普通进程，使用FIFO或者Round Robin来调度。
> 之后Linux使用O(1)复杂度的调度策略，也是基于动态优先级的，并且维护了多个优先级队列。调度器根据平均睡眠时间等来推测交互式进程和批处理进程。对于实时进程的处理没有变化。
> 在之后又有了CFS调度策略，该策略并不使用动态优先级的思路。对于实时进程处理没有变化。对于普通进程，用完时间片后，进入更低的优先级队列。当进程到达最低优先级队列并用完时间片后，进程回到比最开始优先级更低一级的优先级队列，同时获得更长的时间片。这个样子就像下楼梯。


[toc]

### 总的知识结构图
![[不活跃主题/操作系统/内存/_attachments/1600092884341-c503245d-6fda-45fc-8a71-c08c7ccd0858.jpg ]]

---


### 程序执行过程

- 从源代码`main.cpp`到可执行的**进程**。需要经历以下三个过程：
  ![[不活跃主题/操作系统/内存/_attachments/1600092884403-4090edf0-b869-474b-a0b0-ab6e8828893f.jpg ]]
- 链接有哪些方式？
   - 静态链接：目标模块和函数库（静态库）组合成一个完整的可执行程序。
   - 装入时动态链接：在装入内存时才进行链接，库函数是单独的文件，比如dll文件
   - 运行时动态链接：与装入动态链接不同的是，只有在执行时才装入，可以减少开始执行的时间。库文件同样是dll。
- 装入有哪些方式？
   - 绝对装入：在编译时已经知道了程序将会被装到什么位置去，所以可以使用绝对地址。比如bootloader和操作系统程序。
   - 静态重定位：程序整个装入，地址都是相对于初址的，地址变换是装入时一次完成的。大概是操作系统，单片机一类的东西吧。
   - 动态重定位：装入内存后的地址仍然是逻辑地址。地址转换在运行时才进行。虚拟内存大概如此。

---


### 地址空间
> 实模式和保护模式
> - 实模式：直接访问物理地址。在CPU启动或复位时就是该模式。
> - 保护模式：开启了CPU的内存保护，分页机制，虚拟内存等功能。

- 进程地址空间
  ![[不活跃主题/操作系统/内存/_attachments/1600092884478-56e27d74-6d9c-4c85-8b33-78d11a15a363.png ]]
- 逻辑地址，线性地址和物理地址
   - 逻辑地址：相对于段基址的偏移。如数据段，代码段，栈段。
   - 线性地址：通过分段机制，逻辑地址加上段基址可以转化为线性地址。线性地址就是**进程地址空间**中的地址了。
   - 物理地址：线性地址通过分页机制可以转换为物理地址。
- ![[不活跃主题/操作系统/内存/_attachments/1600092884524-2139ee95-3f9e-4d8b-b04a-3b13058b5c9c.png ]]
- 动态重定位：类似于`物理地址=段基址+段偏移`
   - 重定位寄存器，界地址寄存器：这两者可以实现一定程度的地址转换和内存保护。
  ![[不活跃主题/操作系统/内存/_attachments/1600092884575-724efbf3-f0db-4cea-ac2c-8ef761396598.png ]]

---


### 内存扩充技术

- 覆盖：对于**一个进程，覆盖自身**，将即将要用到的段装入主存，一些段可以换到外存中去。被虚拟内存机制替代了。
- 交换：对于**很多进程，提高内存利用率**，例如**中级调度**。把暂时不会用到的进程从内存移动到辅存；把准备好的进程从辅存移动到内存。
- 虚拟内存技术：现在和分页机制，分段机制结合起来使用的。

---


### 内存分配：连续分配
> 连续分配是指：**进程在主存中是连续存放的。**

![[不活跃主题/操作系统/内存/_attachments/1600092884627-06878aa3-fb5e-4b10-8c58-d38de44969d3.jpg ]]

- 单一连续分配：整个主存被划分为两个区域：系统区和用户区，**用户区中只有一个进程在运行**。这种方式适合单用户，单任务的系统。
- 固定分区分配：**将用户内存空间预先进行划分**，这些分区大小可以相等也可以不等。
- 动态分区分配：不预先划分内存，进程装入时才为进程动态地建立分区。系统中分区大小和数目是可变地。
   - 首次适应：分区**按照地址**形成链表；顺序查找，把第一个满足进程要求的分区分配出去。**最快最好**
   - 最佳适应：分区按照**容量递增**的形式组织成链表。
   - 最坏适应：与最佳适应相反。分区按照**容量递减**的形式组织成链表。
   - 邻近适应：由首次适应演变而成，从上次结束的位置开始继续查找。

---


### 内存分配：非连续分配
> 非连续分配：**进程在内存中不是连续存在的。**
> 非连续分配管理方式中，**分区大小固定**的叫做分页式存储管理；**分区大小不固定的**，叫做分段式存储管理。


##### 基本分页存储管理

- 基本分页区别于请求分页：$\color{red}{基本分页需要把所有页面都调入内存才能运行。}$
- 它是如何运作的：将内存和进程都进行划分，将进程的页面安放在内存的页框中，通过页表来记录放置关系，通过地址变换机构来实现地址转换。
- 进程和内存的划分：将进程划分为**页面**，内存划分为**页框**，外存划分为**块**。
- 页表：页表项记录了**进程的页面号**和**内存页框号**的对应关系。
  ![[不活跃主题/操作系统/内存/_attachments/1600092884674-01116561-48a9-4a1c-a65c-2a3e467669f5.png ]]
- 逻辑地址的组成：页面号+页内偏移。其中，页面的大小决定了页内偏移的长度。
  ![[不活跃主题/操作系统/内存/_attachments/1600092884716-94bec242-b296-49c3-908f-65f3db14fc46.png ]]
- 地址变换机构
   - 页表寄存器：存放的是页表的起始地址（相当于数组指针）；还可以用于越界判定。**页表起始地址**存放在PCB中。
  ![[不活跃主题/操作系统/内存/_attachments/1600092884753-32aa637c-c168-4ae1-9627-8a6d07fe135d.png ]]
- 两级页表：`逻辑地址：一级页号 - 二级页号 - 页内偏移`

##### 基本分段存储管理
> 注意和8086的地址做区分。
> 8086地址共20位，被划分为16位的段地址和16位的段偏移，段地址和段偏移**发生了重叠**。
> 分段机制中，段号和段偏移并**不会重叠**。

- 分段机制要求一个段内的内存是连续的。也就是说，将程序划分为很多段，分散在主存中。**段的划分是手动（编译器）进行的，段长并不相等**。
- `逻辑地址: 段号 - 段内偏移`：以下图为例：一个程序最多划分为$2^{16}=65536$段，每段最大为16KB。段长可以小于16KB，不能大于16KB

![[不活跃主题/操作系统/内存/_attachments/1600092884790-96ac1321-9a29-485b-8654-6af1c65c09a5.png ]]

- 段表：存放了**逻辑段**到**物理存储区**的映射
- 地址变换机构：段表项还存放了段长（因为段长不相等），与段内偏移比较，判断地址是否越界。
	![[不活跃主题/操作系统/内存/_attachments/1600092884832-a213ed2f-b957-49de-acaf-7d1ea66874c7.jpg ]]

##### 段页式存储管理

- 如何进行的：将一个程序划分为很多段，每一段又用分页机制分开存放。`逻辑地址=段号-页号-页内偏移`。首先根据段号和段表查找到相应的页表，再根据页表和页号得到块号，最后组合块号和页内偏移就得到了物理地址。
   - 这种情况下，一个进程只有一个段表，有多个页表。只需要一个段表寄存器即可。
- 地址变换
  ![[不活跃主题/操作系统/内存/_attachments/1600092884864-356d286f-35af-4779-ad43-370dfb359b78.jpg ]]

---


### 虚拟内存：请求分页管理机制
> 虚拟存储管理可以解决以下问题
> - 程序必须一次性全部装入内存后才能够开始运行。
> - 程序被装入内存后，就一直驻留在内存中，直到结束才会被换出。
> 
虚拟存储器的特征
> - 请求调页：运行时不必全部装入内存，需要时再调入
> - 页面置换：可以将不活跃的部分换出内存
> - 虚拟存储器：容量是由地址结构决定的，比如32位的虚拟地址空间就是4G


###### 页面置换算法
	当需要访问的页面不在内存中，而内存又没有空闲时，**需要有一个算法来判断该把哪页换出**

- 最佳置换算法**OPT**：淘汰**最长时间不再被访问**的页面。这个算法无法实现，只能作为评判标准。
- 先进先出置换算法**FIFO**：优先淘汰最早进入内存的页面。还会出现**Belady异常**。
- 最近最久未使用算法**LRU**：淘汰过去最长时间未被访问过的页面。
- 时钟置换算法**CLOCK**：又叫最近未使用算法**NRU**。
   - 将一些**页框**组成一个**循环缓冲区**，有一个**指针**与之关联。每个**页框**都关联一个**使用位u**和**修改位m**。
   - 页面被装入或者页面被访问时：将使用位u置为1。
   - 发生替换后：指针指向下一位
   - 选择替换时
      - a：进行一次循环扫描，寻找未使用未修改的页框（u=0，m=0），扫描过程中不修改任何位。
      - b：若a失败，则再扫描一次，寻找未使用已修改的页框（u=0，m=1），扫描过程中将遇到的页框使用位u置为0。若b也失败，再从a开始。
   - ![[不活跃主题/操作系统/内存/_attachments/1600092884901-08a35211-48ec-4262-affd-7b7f254b0240.png ]]

###### 页表项

- 为了支持页面置换算法，需要对**页表项**进行修改。![[不活跃主题/操作系统/内存/_attachments/1600092884934-37168004-25ec-4d9b-9e97-9d97517daf70.jpg ]]
   - `页号`和`物理块号`：是基本分页式中的页表项。
   - `状态位`：表示该页面是否在内存中，供**程序访问**时参考。
   - `访问字段`：记录该页面在一段时间内的访问情况，供**页面置换算法**参考。
   - `修改位`：表示该页在调入内存后是否经历过修改。
   - `外存地址`：供**调入该页**时参考。

###### 页面分配策略

- 驻留集：虚拟内存管理机制并不会把进程的所有页面调入内存，分配给一个进程的页框合集就叫做驻留集。
   - 固定分配局部替换：替换发生在进程内
   - 可变分配全局替换
   - 可变分配局部替换：如果频繁发生缺页，就增大驻留集。
- 页面调入时机：预调页策略和请求调页策略。（Linux使用一个守护进程来清理页面，进行页面调出）
- 工作集：在某段时间间隔内，进程访问过的页面的集合。工作集是通过工作窗口的方式得到的。当程序的局部性较好时，工作集会比工作窗口小很多。

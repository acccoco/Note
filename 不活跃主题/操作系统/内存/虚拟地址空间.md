
在操作系统中运行一个程序时，CPU看到的地址时虚拟地址空间的地址。
> 关于保护模式和实模式，这个是CPU的运行状态，在上电和复位时CPU是运行在实模式下的。


地址总线宽度和寄存器位数：
地址总线宽度决定了物理地址空间；寄存器的位数决定了虚拟地址空间

CPU如何根据虚拟地址来寻址？
要回答这个问题，需要结合处理器和操作系统来说：
x86的处理器支持分段机制和分页机制（分页机制需要专门的硬件：MMU），linux操作系统似乎只使用了分页机制
以x86-linux为例：CPU要进行寻址，操作系统只需要提供与分页机制相关的数据结构即可

寻址图如下所示；


操作系统需要提供xx表，每个进程有一张这种表，操作系统负责维护。在寻址时，需要将进程对应的表项装载。

分段机制似乎没法关闭，linux的做法好像是这样的：让所有的段基址都相同

这里有一些概念需要理清楚：分段分页可以解决程序动态加载的问题，内存扩充是基于分段分页来实现的。



#### 逻辑-线性-物理地址
> TODO 本节内容参考：[https://blog.csdn.net/do2jiang/article/details/4512417](https://blog.csdn.net/do2jiang/article/details/4512417)

逻辑地址是程序员可以看到的地址；物理地址是硬件的地址。线性地址是逻辑地址到物理地址中间的一个地址。
通常是逻辑地址 + 段偏移。这个过程和硬件有关（gdtr，ldtr），也和软件有关（GDT，LDT），还和段选择符T1有关。（深挖一下）
如下图所示：
![[不活跃主题/操作系统/内存/_attachments/1601128050395-9fb43a1b-fe02-4d55-aea9-0635792a9389.jpeg | 615]]
逻辑地址到线性地址的转换过程：
首先，给定一个完整的逻辑地址_[_段选择符：段内偏移地址_]_，
_1_、看段选择符的_T1=0_还是_1_，知道当前要转换是_GDT_中的段，还是_LDT_中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。
_2_、拿出段选择符中前_13_位，可以在这个数组中，查找到对应的段描述符，这样，它了_Base_，即基地址就知道了。
_3_、把_Base + offset_，就是要转换的线性地址了。 还是挺简单的，对于软件来讲，原则上就需要把硬件转换所需的信息准备好，就可以让硬件来完成这个转换了。

> linux中，逻辑地址和线性地址总是相同的。这个可以在linux的代码中得到印证。
> 不同段的标志是宏定义，根据其查找段基址，发现段基址都是0.


分页机制的示意图：
![[不活跃主题/操作系统/内存/_attachments/1601128543576-60fafd45-bcaf-426d-8ad7-66f041408a0e.jpeg | 611]]



##### GDT
全局描述符表，是一个在内存中唯一的数据结构
GDT相关的机制是由硬件和系统一起实现的
intel专门提供了一个GDTR寄存器来存放GDT的入口地址，程序员可以通过LGDT指令来装入。

> GDT表有什么用？




#### Unix的5中IO模型
每个IO过程都可以划分为两个阶段

- 等待准备数据的阶段
- 将数据从内核复制到用户空间的阶段

![[不活跃主题/Unix编程/socket编程/_attachments/1600052153715-7832f6bf-98f8-48b4-8fa7-d2ba203b2eef.png ]]

##### 1. 阻塞式
```c
char recv[256];
fgets(recv, 256, stdin);
```
![[不活跃主题/Unix编程/socket编程/_attachments/1600052153776-f660de33-ca8a-47c7-8b49-29b16b84b6f3.png ]]

##### 2. 非阻塞式
通过某些选项开启：系统调用立刻返回
这种IO模型一般配合轮询来使用

##### 3. IO复用
这种IO模型是阻塞的，不会阻塞于某一个具体的IO请求上，而是阻塞于`select`或者`poll`系统调用上

##### 4. 信号驱动
一般过程为：

- 首先注册`SIGIO`的信号处理函数；

- 然后进行IO，并声明以`SIGIO`的形式通知；

- 之后进程继续运行

- 内核向进程发送`SIGIO`信号，告诉进程可以启动IO操作了

- 进程转到内核执行IO操作

- 然后进程继续运行


请求IO的进程，在等待数据准备好期间不会阻塞，在数据从内核复制到进程时会阻塞。

##### 5. 异步IO
与信号驱动的区别在于，内核不是在可以进行IO操作时通知进程，而是在IO操作已经完成时通知进程。
不会导致请求IO的进程阻塞

#### POSIX的同步IO与异步IO
POSIX规定了什么是同步IO，什么是异步IO

- 同步IO：导致请求进程阻塞，知道IO操作完成
- 异步IO：不导致请求进程阻塞

从上面的定义来看，只有异步IO模型符合POSIX的异步IO定义；前四种IO模型都是同步IO模型。

[toc]

#### - 格式转换

##### 1. 字节序
网络上的字节序和本地的字节序是否相同

##### 2. 地址转换
在ASCII字符串和网络字节序的数字地址之间的转换
可以通过以下函数进行：
```c
/* 仅适合IPv4 */
#include <arpa/inet.h>
int inet_aton(const char* strptr, struct in_addr* addr);
int_addr_t inet_addr(const char* strptr);
char* inet_ntoa(struct in_addr inaddr);
/* 适合IPv4与IPv6 */
#include <arpa/inet.h>
int inet_pton(int family, const char* strptr, void* addrptr);
const char* inet_ntop(int family, const void* addrptr, char* strptr, size_t len);
```

#### - 选择何种套接字
套接字地址结构：这个结构体用来存放连接的地址信息，比如IP地址和端口号等；以及指定套接字的协议类型。

#### - 字节操作函数
比如字节内存复制，比如内存全部置为0
常用两种类型的字节操作函数：

##### 1. 源自BSD
```c
#include <strings.h>
void bzero (void *s, size_t len);
void bcopy(const void* src, void *dest, size_t len);
int bcmp(const void* s1, const void* 2, size_t len);
```

- `bzero`：将s的n个字节设置为0。
- `bcopy`：从`src`复制n个字节到`dest`
- `bcmp`：比较`s1`和`s2`的n个字节是否相同。相同则返回0，不相同则返回非0。

##### 2. 源自ANSI C
```c
#include <string.h>
void* memset(void* s, int c, size_t len);
void* memcpy(void* dest, const void* src, size_t len);
int memcmp(const void* s1, const void* s2, size_t len);
```

- `memset`：将指定字节数设为`c`。

#### - 信号处理
注意：阻塞的慢调用可能会被其他调用中断，从而出现`EINTER`错误。应该重启这些调用。
在处理信号的过程中，新到来了同种信号，比如`SIG_CHLD`信号。如何做才能不至于错过处理这些信号。

#### - 使用何种IO模型
有4种IO模型可以使用

##### 1. 阻塞式
一般需要子进程来处理到来的连接
如果使用了子进程，就需要考虑以下方面

- 处理`SIG_CHLD`信号
- 管理通过父进程复制的一些资源：比如共享的描述符

##### 2. 非阻塞式

-  TODO

##### 3. IO复用
选择使用`select`函数还是`poll`函数
管理描述符集合

##### 4. 信号驱动

-  TODO

#### - 使用缓冲
注意：混合使用`select`和带有缓冲的流`stdin`可能会出错
在`read, write`上面使用缓冲可以显著减少用户CPU时间。

#### - 其他注意

##### 1. 值-结果参数
值结果参数是一种人为约定，而不是语法规范。它的实质是指针。
以下图为例：
![[不活跃主题/Unix编程/socket编程/_attachments/1600052153995-9d14b514-c17b-43b9-b167-302fd17f698b.png ]]
在调用时，传入的`len`告诉内核结构体大小有多少，防止内核读写越界。
在返回时，内核通过`len`告诉用户，自己往里写了多少内容。

##### 2. 客户端何时终止连接
如果这个客户端将终端的内容发送到服务器。当终端输入EOF时，并不要终止客户端，因为客户端还要接收数据。

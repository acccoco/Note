

### 操作原语的比较
|  | 进程 | 线程 |
| --- | --- | --- |
| 创建新的控制流 | `fork`  | `pthread_create`  |
| 退出当前控制流 | `exit`  | `pthread_exit`  |
| 异常退出当前控制流 | `abort`  | `pthread_cancel`  |
| 得到某个控制流的退出状态 | `waitpid`  | `pthread_join`  |
| 获得当前控制流的ID | `getpid`  | `pthread_self`  |



### 拥有的资源对比
线程独有的资源，线程共享的资源（进程的资源）如下：
![[不活跃主题/Unix编程/线程/_attachments/1606025641017-56c57e6a-b33e-4da8-8e6c-17fbceab8d2b.png | 504]]


### linux中线程的实现
linux中的线程的实现主要是 `NPTL` 库（Native Posix Thread Library），它提供了线程的一系列的操作 `pthread_` 
linux中的线程实际上是“轻量级”的进程。在内核看来，线程和进程没有区别，都是 `task_struct` 。
![[不活跃主题/Unix编程/线程/_attachments/1604237301001-15195fd0-20ff-4878-89d2-b7e2ba2debd0.png | 494]]

线程是“轻量级”的进程，“轻量级”体现在哪里？
体现在同属一个进程的各个线程，他们的 `task_struct` 的某些字段指向相同的结构体，如图所示：
![[不活跃主题/Unix编程/线程/_attachments/1604236930650-676109e9-bf83-4623-8ae8-3498cd7200ff.png | 580]]
`pthread` 的实现离不开 `clone` 这个系统调用。实际上， `fork` 也会调用 `clone` 。
`clone` 支持 `clone_flags` 这个参数，通过这个参数可以实现在线程之间共享一些进程资源：
```c
int clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGNAL | ...);
```



### 本文资源
[线程.drawio](https://www.yuque.com/attachments/yuque/0/2020/drawio/2323228/1606025710401-4a516106-9450-44c9-a291-b3602d34e375.drawio)



### 列表定义
- 列表中的元素类型必须相同

```haskell
-- 列表的类型说明和定义
l1 :: [Int]
l1 = [1, 2, 3]
```

注：字符串也是列表，这是 Haskell 的语法糖。`"123"` 对应 `['1', '2', '3']`


### 列表操作
**连接两个列表**：
使用 `++` 运算符
```haskell
[1, 2, 3] ++ [4, 5]
```

**向列表中添加元素**：
通过 `:` 向列表的头部添加元素
```haskell
1 : [2, 3, 4]
-- [1, 2, 3, 4]

1 : 2 : 3 : []
-- [1, 2, 3]
```

**获取列表元素**：
通过 `!!` 获取指定下标的元素，下标从 0 开始：
```haskell
[1, 2, 3] !! 1
```

**列表的比较**：
将列表看作是一个单词，比较就按照**字典序**来进行
```haskell
[1, 2, 3] > [2]
-- False
```

**列表的函数操作**：
```haskell
head [1, 2, 3]
-- 1
last [1, 2, 3]
-- 3
init [1, 2, 3]
-- [1, 2]
tail [1, 2, 3]
-- [2, 3]
length [1, 2, 3]
-- 3
null [1, 2, 3]
-- False
reverse [1, 2, 3]
-- [3, 2, 1]
take 2 [1, 2, 3]
-- [1, 2] 取前 n 个元素
drop 2 [1, 2, 3]
-- [3] 扔掉前 n 个元素
maximum [1, 2, 3]
-- 3
minimum [1, 2, 3]
-- 1
sum [1, 2, 3]
-- 6
product [1, 2, 3]
-- 6 计算所有元素的乘积
elem 4 [1, 2, 3]
-- False 元素是否在列表中
```

获取满足条件的列表前缀：
```
takeWhile (<3) [1,2,3,4,5,6,7]
-- [1,2]
```

**自动生成列表**：
range 操作：
```haskell
['a'..'d']
-- ['a', 'b', 'c', 'd']
['a', 'd' .. 'k']
-- ['a', 'd', 'g', 'j'] 通过这种方式来指定步长
[1, 2,..]
-- 无限列表
take 3 [1..]
-- [1, 2, 3] 取无限列表的前 3 个
```

无限长的列表
```haskell
take 4 (cycle [1, 2, 3])
-- 通过 cycle 函数生成无限循环的列表，再取前 4 个元素
-- 得到 [1, 2, 3, 4]

take 4 (repeat 3)
-- [3 3 3 3]
```

重复元素的列表：
```haskell
replicate 3 10
-- [10 10 10]
```

不断地为列表元素应用一个函数，生成无限的列表：
```
iterate f a
-- [a, f a, f (f a), ...]
```


### 列表推导式
```haskell
[x*2 | x <- [1..10], x*x < 50, odd x]
-- [2, 6, 10, 14]
```

上述等价于：
$$\{
	2x | 1 \le x \le 10, x^2 < 50, x 是奇数
\}
$$

类似笛卡尔积的列表推导式：
```haskell
[[x, y] | x <- [0..100], y<-[0..100], x^2 + y^2 < 5, x^2 + y^2 > 0]
-- [[0,1],[0,2],[1,0],[1,1],[2,0]]
```

上述等价于：
$$
\{
	(x, y) | 0\le x,y \le 100, 0 <x^2 + y^2 < 5
\}
$$

可以结合 `if else` 表达式来：
```haskell
[if n < 3 then 0 else n | n <- [1..5]]
-- [0,0,3,4,5]
```

**可以在列表推导式的途中定义变量**：
```
  [ (x * y, z)
    | x <- [1 .. 10],
      y <- [1 .. 10],
      let z
            | x < 5 = (-1) * x
            | otherwise = x
  ]
```


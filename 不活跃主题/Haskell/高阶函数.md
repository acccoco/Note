
### currying
Haskell 里面实际上只有**单参数**的函数，多参数的函数是语法糖。所以多参数函数的类型声明才那么奇怪。
例如：
```haskell
add :: Int -> Int -> Int
add x y = x + y

-- 实际上是
add :: Int -> (Int -> Int)
add x y = x + y
```

通过「接受但参数，并返回一个函数」的形式来实现多参数函数的方法叫做 `currying`。（这是个人名，全名叫做 Haskell Curry）

`curry` 函数可以将非 `curried` 的函数转换为 `curried` 的函数，`uncurry` 相反：
```haskell
uncurry (+) (2, 3)
-- 5

add :: (Int, Int) -> Int
add (x, y) = x + y

add (2, 3)
-- 5

curry add 2 3
-- 5
```


### 偏函数
对于一个多参数函数，设定某些参数的值，得到一个新的函数，这个过程叫做 `partial application`
由于 Haskell 的所有函数都是 `curried` 的，所以这个过程非常容易实现

缺少参数的函数可以直接作为一个新的函数：
```haskell
add :: Int -> Int -> Int
add a b = a + b

-- 通过 add 生成新函数 add3
add3 :: Int -> Int
add3 x = add 3

-- 在 map 中使用临时生成的函数
map (add 3) [1..3]
-- [4,5,6]
```

`**point-free**`** 风格**：
定义一个函数的时候，不涉及到参数，比如：
```haskell
-- 找到列表中大于 3 的数，并乘以 7 + 2，最后求和
foo :: [Integer] -> Integer
foo = sum . map (\x -> x*7 + 2) . filter (>3)
```


### 匿名函数
lambda 表达式的格式为 ：`\参数 -> 返回值`
比如：
```haskell
map (\n -> if n > 3 then n else 0) [1, 2, 3, 4, 5]
-- [0, 0, 0, 4, 5]
```

缺操作数的运算符也可以作为匿名函数：
`(>3)` 就等价于 `(\x -> x > 3)`


### 函数结合
如果想要像流程管线一样一个接一个的使用函数：
```
-- 列表中大于 3 的数的数量是否是偶数
foo :: [Integer] -> Bool
foo xs = even (length (filter (> 3) xs))
```

可以使用 `.` 运算符来进行改写：
```haskell
foo :: [Integer] -> Bool
foo = even . length . (filter (>3))
```


### fold
通过 fold 可以让某些情况的递归更优雅
```haskell
fold :: (a -> b -> b) -> b -> [a]-> b
```
等价于：$b_0 = a_0, b_n = f(a_n, b_{n-1})$ 

列表求和可以用 `foldr` 表示为：
```haskell
sum :: [Integer] -> Integer
sum = foldr (+) 0 
```

其中，`foldr` 的第一个参数表示递推函数；第二个参数表示空列表应该得到多少
`foldl` 表示从最左边的元素开始计算；`foldr` 表示从最右边的元素开始计算：
```haskell
foldl f z [a,b,c] == a `f` (b `f` (c `f` z))
foldr f z [a,b,c] == ((z `f` a) `f` b) `f` c
```


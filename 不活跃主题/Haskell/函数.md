
### 函数调用
**普通的调用方式**：
参数以空格隔开。比如有一个名为 `add`  的函数，接受两个参数，这样调用：
```
add 1 2
```

注：**函数的优先级是最高的**。函数表达式最先发生结合

**插入式的调用方式**：
```haskell
-- 正常调用i
add 1 2
-- infix 方式调用
1 `add` 2
```


### 偏函数和全函数
偏函数：有些输入会导致函数崩溃，或者无限递归。比如 `head, tail, !!` 这些函数（`head`  会在空列表时崩溃）

全函数：对于所有的输入，函数都能够很好地处理。

注：**尽量不要使用偏函数**。

可以使用模式匹配来替代一些：

```haskell
foo :: [Int] -> Int
foo [] = 0
foo xs = head xs

-- 替换为
foo [] = 0
foo (x:_) = x
```

使用 `Maybe` 类型也可以避免偏函数：

```haskell
-- Maybe 的定义长这样
data Maybe t = Nothing | Just t

-- 使用 Maybe 重写 head 函数
safeHead :: [t] -> Maybe t
safeHead []    = Nothing
safeHead (x:_) = Just x
```

**函数定义**：

函数名称后面是参数列表，等号后面是返回值的表达式

```haskell
-- 注意这里的类型声明，两个参数一个返回值
acc :: Int -> Int -> Int
acc p1 p2 = p1 + p2
```


### 函数的例子
**斐波那契函数的定义**
```haskell
-- 这个必须在文件中定义
fab :: Int -> Int
fab 0 = 0
fab 1 = 1
fab n = fab (n - 1) + fab (n - 2)
```

或者这样定义：
```haskell
fab :: Int -> Int
fab n
  | n == 0 = 0
  | n == 1 = 1
  | otherwise = fab (n - 1) + fab (n - 2)
```

**汉诺塔**：
```haskell
type Peg = String
type Move = (Peg, Peg)

hanoi :: Integer -> Peg -> Peg -> Peg -> [Move]
hanoi n a b c
  | n <= 0 = []
  | n == 1 = [(a, b)]
  | otherwise =
    hanoi (n - 1) a c b
      ++ [(a, b)]
      ++ hanoi (n - 1) c b a
```


### 函数参数的模式匹配
```haskell
sum' :: [Integer] -> [Integer]
sum' [] = []
sum' [x] = [x]
sum' (x : (y : zlist)) = (x + y) : sum' zlist

-- sum' [1, 2, 3, 4, 5]
-- [3, 7, 5]
```


### `lambda` 表达式
格式为 ：`\参数 -> 返回值`
比如：
```haskell
map (\n -> if n > 3 then n else 0) [1, 2, 3, 4, 5]
-- [0, 0, 0, 4, 5]
```


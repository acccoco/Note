在递归编程时经常会遇到这样的情况：需要检测是否需要继续执行递归，这个检测既可以在主调函数中进行，也可以在被调函数中进行，两种方法有什么区别。


#### 以先序遍历为例

在主调函数中做判断的例子：
```cpp
void traversal(const Node *node){
	assert(node != nullptr);
    
    print(node);
    if (node->l_child) traversal(node->l_child);
    if (node->r_child) traversal(node->r_child);
}
```

在被调函数中做判断的例子：
```cpp
void traversal(const Node *node){
	if (node == nullptr) return;
    print(node);
    traversal(node->l_child);
    traversal(node->r_child);
}
```

下面的表格列举出了这两种策略的比较：

|  | 主调函数判断 | 被调函数判断 |
| --- | --- | --- |
| 判断的类型 | 主调函数：调用前要做参数判断
被调函数：使用断言 | 主调函数：调用后要做额外的返回值判断
被调函数：需要做参数检查 |
| 是否增加调用次数（递归） | 不会 | 增加一次 |
| 评价 | 这种对函数的把握更流畅些 | 需要区分正常的返回值和因参数问题导致的特殊返回值 |



#### 结论
递归函数中，统一在主调函数中做判断，确保传给被调函数的参数都是没问题的。
被调函数会通过断言确保不会犯低级错误。


> [!info] 各种设计模式的参考
> [GOF](https://java-design-patterns.com/tag/gang-of-four/)


## UML 图示
![[_attachments/1600093640480-f709e0ea-b9da-4dd7-8b5a-b4a526496314.png | 500]]

---


## 创建


### 单例模式


### 原型模式

原型模式可以用于大量相同或相似对象的创建。

以一个已经创建的对象作为原型，通过复制该原型来创建其他对象。

这种设计模式一般用于：构造函数非常耗费时间，而复制对象可以减少时间开销。

原型模式的要素：

- 提供`clone()`方法即可



### 工厂模式

精灵铁匠和兽人铁匠都是铁匠，可以锻造具有自己种族特色的武器。

```rust
trait Weapon {}

/// 武器的类型
enum WeaponType {
    Axe,
    Spear,
}

/// 具体的武器
struct ElvenSpear;
struct ElvenAxe;
struct OrishSpear;
struct OrishAxe;
impl Weapon for ElvenSpear {}
impl Weapon for ElvenAxe {}
impl Weapon for OrishSpear {}
impl Weapon for OrishAxe {}

/// 铁匠
trait Blacksmith {
    fn manufacture_weapon(weapon_type: WeaponType) -> Box<dyn Weapon>;
}

/// 精灵铁匠，专门生成精灵武器
struct ElfBlacksmith;
impl Blacksmith for ElfBlacksmith {
    fn manufacture_weapon(weapon_type: WeaponType) -> Box<dyn Weapon> {
        match weapon_type {
            WeaponType::Axe => Box::new(ElvenAxe),
            WeaponType::Spear => Box::new(ElvenSpear)
        }
    }
}

/// 兽人铁匠，专门生产兽人武器
struct OrcBlacksmith;
impl Blacksmith for OrcBlacksmith {
    fn manufacture_weapon(weapon_type: WeaponType) -> Box<dyn Weapon> {
        match weapon_type {
            WeaponType::Axe => Box::new(OrishAxe),
            WeaponType::Spear => Box::new(OrishSpear)
        }
    }
}
```



### 建造者模式

对象很复杂，如果使用构造函数进行创建，需要非常多的参数。

以角色创建为例：

```rust
pub struct Charactor {
    /// 基本属性
    name: String,
    age: u32,
    gender: u32,

    /// 外貌属性
    hair_color: String,

    /// SPECIAL 属性
    strength: u32,
    perception: u32,
    endurance: u32,
    charm: u32,
    intelligence: u32,
    agility: u32,
    lucky: u32,
}

pub struct CharactorBuilder {
    /// 基本属性
    name: String,
    age: u32,
    gender: u32,

    /// 外貌属性
    hair_color: String,

    /// SPECIAL 属性
    strength: u32,
    perception: u32,
    endurance: u32,
    charm: u32,
    intelligence: u32,
    agility: u32,
    lucky: u32,
}

impl CharactorBuilder {
    pub fn new(name: String, gender: u32) -> CharactorBuilder {
        todo!()
    }

    /// 设置各种 SPECIAL 属性
    pub fn with_special(self) -> Self {
        todo!()
    }
    
    /// 创建角色
    pub fn build(&self) -> Charactor {
        todo!()
    }
}
```

---


## 结构型

结构型模式不关心如何构建对象，而是关心对象之间的结构。


### 适配器模式

比如将港版的插头使用适配器转换为大陆的插头。

适配器模式会改变原有的接口。


### 桥接模式

不同的武器，不同的附魔组合起来

```rust
trait Enchantment {
    /// 附魔激活的效果
    fn active(&self);
}

struct SoulEatingEnchantment;
impl Enchantment for SoulEatingEnchantment {
    fn active(&self) {
        todo!()
    }
}


struct FireEnchantment;
impl Enchantment for FireEnchantment {
    fn active(&self) {
        todo!()
    }
}

trait Weapon {
    fn new(enchantmant: Box<dyn Enchantment>) -> Self;

    /// 获取武器的附魔状态
    fn enchantmant(&self) -> &dyn Enchantment;

    /// 使用附魔状态进行攻击
    fn attach(&self) {
        self.enchantmant().active();
    }
}

struct Axe;
impl Weapon for Axe {
    ...    
}

struct Sword;
impl Weapon for Sword {
    ...
}
```

[桥接模式](https://java-design-patterns.com/patterns/bridge/)


### 组合模式

将对象组合起来，允许以相同的方法来处理单个或者一组对象。

例如：光追中的单个对象和 BVH 对象都是 Hittable 的。



### 装饰器模式

不改变对象的接口，通过将对象包装在新的对象中，修改对象的功能。


### Flyweight 模式

炼金商店中有大量药水，很多药水都是相同的，可以共享减少内存。

```rust
trait Potion {}

#[derive(Eq, Hash, PartialEq, Clone, Copy)]
enum PotionType {
    Healty,
    HolyWater,
}

/// 各种药水
struct HealtyPotion;
struct HolyWaterPotion;
impl Potion for HealtyPotion {}
impl Potion for HolyWaterPotion {}

/// 炼金商店
struct AlchemistShop {
    potions: std::collections::HashMap<PotionType, Box<dyn Potion>>,
}

impl AlchemistShop {
    fn add_potion(&mut self, potion_type: PotionType) -> &dyn Potion {
        if self.potions.get(&potion_type).is_none() {
            match potion_type {
                PotionType::Healty => {
                    self.potions.insert(potion_type, Box::new(HealtyPotion));
                }
                PotionType::HolyWater => {
                    self.potions.insert(potion_type, Box::new(HolyWaterPotion));
                }
            }
        }

        self.potions.get(&potion_type).unwrap().deref()
    }
}

```



---


## 行为

### 责任链模式

请求从链表的一端进入，不断地从一个对象到另一个对象，直到找到合适的对象来处理请求。

> 例如：将多个 logger 构成链表，消息到来时，每个 logger 都可以进行相应处理。


[责任链模式](https://java-design-patterns.com/patterns/chain-of-responsibility/)


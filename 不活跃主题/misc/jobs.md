
#### jobs用法
`jobs` 是 `bash` 的 `builtin` 命令，类似的还有：`bg, fg, kill`
任务：任务是和当前 `shell` 绑定的

- 使用 `cmd &` 执行的命令，被作为一个 `job`，可以通过 `jobs` 看到；
- 但是使用 `$(cmd &)` 执行的，无法通过 `jobs` 看到；因为不是当前 `shell` 的 `job`
```shell
job -l     # 可以列出详细的信息
bg         # 让前台任务到后台执行，和 & 有一样的效果。可以先使用 ctrl + z 将任务挂起，然后 bg
fg         # 将后台任务放到前台来执行
nohup：这个命令设置子进程对信号的处理方式：不会因为 shell 停止而停止
kill：除了可以向进程发送信号，还可以向任务发送信号
```


#### 常见用法：
```shell
nohup cmd > cmd.log 2>&1 &
```


#### 会话，进程组，作业
查看终端的文件描述符可知：`stdin, stdout, stderr` 都是指向终端设备的：

```shell
# /proc/pid/fd/
0 -> /dev/pts/0
1 -> /dev/pts/0
2 -> /dev/pts/0
```

`shell` 的作业控制：可以运行一个前台作业和若干个后台作业
前台任务会独占命令行窗口

一次会话：比如打开一个终端
会话有会话ID：`SID`，通过这次会话启动的前台任务和后台任务都具有相同的`SID`。
当会话结束时，会向同属一个会话的所有进程发送 `SIGHUP` 信号。`nohup` 命令可以让进程在会话结束后任然运行

作业：一个作业可以包含若干个进程，可以认为一个作业就是一个进程组.
```shell
# 会创建一个后台任务，包含三个进程，三个进程有相同的PGID
sleep 100 | sleep 100 | sleep 100 &
```

在脚本里面设置了 `cmd &`，然后执行这个脚本，会发现那么 `cmd` 的 `ppid=1`，这是因为用来执行脚本的 `bash` 进程死掉了

```shell
#!/bin/bash
sleep 100 &
jobs -l
```

在脚本里面使用 `jobs` 会有信息，在外面使用 `jobs` 没有信息，大概是因为 作业 是 `bash` 里面的概念吧

会话，进程组，作业的关系：

![[_attachments/1599447710117-6278224f-07ae-4f16-8376-7d00456316c8.png | 532]]


#### 守护进程：
守护进程没有什么特殊的，只要符合一定的规则，就可以称为守护进程：

- `stdin, stdout, stderr` 不是 `/dev/tty/xxx`，这样，在终端退出后不会出错
- 不会被终端退出时的信号 `SIGHUP` 干掉，可以使用 `nohup cmd` 实现

可以通过 `systemd` 这个工具来管理守护进程，这个工具是系统自带的，值得注意的是：其进程号 `PID = 1`

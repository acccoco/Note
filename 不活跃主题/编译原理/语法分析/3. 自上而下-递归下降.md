
#### 递归下降分析方法
- 每一个生成规则，对应一个函数。
- 对于文法：$G: S\Rightarrow cAd;;A\Rightarrow ab$，其递归下降的分析方法为：
```cpp
void S() {
	match(c);		// 终结符
    A();			// 非终结符
    match(d);
}
void A() {
	match(a);
    match(b);
}
void match(TokenType tokenExpected) {
	if (currentToken.tokenType == tokenExpected) {
    	currentToken = scanner.getToken();
    }
    else {
    	error("expected, but not found");
    }
}
```

#### 递归下降的局限性

##### 1. 直接无限递归：左递归

- 遇到左递归$A\to A\alpha|\beta$时，递归下降无法工作。

- 可以使用巴科斯范式进行改造：
   - $A\to A\alpha|\beta$ 可以改造为：$A\to \beta{\alpha}$
   - $A\to\alpha A|\beta$ 可以改造为：$A\to{\alpha}\beta$
- 例如：对于$exp\to term{addop;term}$

```cpp
void exp() {
	term();
    while(currentToken == addop) {
    	addop():
        term();
    }
}
```

##### 2. 间接无限递归

- 间接递归时，可能导致死循环

$$
{
\quad S\to Ab|c\
\quad A\to Sa
}
$$

- 可以这样改造：

$$
{
第一步：S\to Sab|c\
第二步：S\to c{ab}
}
$$

##### 3. 都是以非终结符开头

- 对于一个非终结符，如果他的所有产生式都是以非终结符开头的，那么可以使用 $First()$ 集合来判断该使用哪个产生式
- 例如：对于产生式 $S \to Ab|Bc$：
```cpp
function S() {
  if currentToken belong to First(A) {
    A();
    match(b);
  }
  else {
    B();
    match(c);
  }
}
```

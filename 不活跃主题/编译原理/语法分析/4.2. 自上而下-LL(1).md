



#### <span style="color:#0202c0;">$LL(1)$ 分析</span>

- $LL(1)$ 分析是一种自上而下的语法分析方法。
  - 第一个 $L$：自左向右地读取输入串
  - 第二个 $L$：从初始符号开始，进行==最左推导==，最后得到输入串的形式
  - $(1)$：在最左推导时，只用向右看一个字符，就可以确定要使用什么产生式
- 使用分析表表来==驱动==；
- 使用栈来辅助：将开始符号放入栈中，逐步使用生成文法来替换非终结符。注意：新的句型入栈时，==右边先入栈==。

![[不活跃主题/编译原理/语法分析/_attachments/Pasted image 20221101004025.png | 400]]



#### <span style="color:#0202c0;">$LL(1)$ 分析表的构建</span>

- 使用 $M$ 来表示分析表。表的行索引是非终结符，表的列索引是终结符
- 基本填法：
  - 如果 $A\to\alpha\beta$，那么对于 $First(\alpha)$ 集合中的每一元素 $a$，将产生式 $A\to\alpha\beta$ 填入`M[A, a]`；
  - 对于 $A\to\alpha$，如果 $\varepsilon$ 在$First(\alpha)$中，那么对于 $\color{red} {Follow(A)}$ 中的每个元素$c$，将产生式 $A\to\alpha$ 填入`M[A, c]`中；
- 总结下：填表的时候先填 $First$ 集合；末尾的非终结符的 $First$ 集合有 $\varepsilon$，就填它的 $Follow$ 集合。
- 遍历方法：遍历所有产生式，而不是遍历非终结符。



#### <span style="color:#0202c0;">$LL(1)$ 的局限性于改造</span>

##### 1. 分析表中一个格子多余一个产生式

如果一个格子里面填入了多于 $1$ 个的产生式，那么称该文法不是$LL(1)$文法，无法处理。

- 可以改用 $LL(k)$ 算法处理，或者等价改造产生式
- $LL(1)$ 文法是上下文无关文法（$2$ 型文法）的子集



##### 2. 左递归

左递归文法不是 $LL(1)$ 文法，无法通过改造为 $BNF$ 范式来解决。因为 $LL(1)$ 是一步推导，无法进行循环。
$$
{
A\to A\alpha,\; A\to\beta\\
BNF改造：A\to\beta\{\alpha\}\\
}
$$

可以改造为右递归：（==要考==）这样，就将循环隐含在分析表中了
$$
A\to\beta B,\; B\to\alpha B|ε
$$
其中，$B$ 的 $BNF$ 可以表示为：$B \to \{\alpha\}\varepsilon$



##### 3. 公共前缀

有公共前缀的产生式不是 $LL(1)$ 文法。因为无法确定该使用什么产生式

改造方法：提取左公共因子，然后将后续写成新的产生式。
$$
A\to xa|xb\\
改造为：A\to xB, B\to a|b
$$



#### <span style="color:#0202c0;">$LL(1)$ 分析算法的流程</span>

![[不活跃主题/编译原理/语法分析/_attachments/Pasted image 20221101004040.png]]

- （todo：上面的流程还需要修改）。
- 其中：`X`表示句型栈顶元素；`currentToken`表示待匹配句子的指针。


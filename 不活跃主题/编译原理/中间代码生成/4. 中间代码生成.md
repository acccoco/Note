

##### 节点的属性

`name`属性（或者`strval`属性）：表示显影的标识符，常量，或编译器生成的临时变量

`tacode`属性：表示文法的三地址码



##### 加法的一个例子

![[不活跃主题/编译原理/中间代码生成/_attachments/Pasted image 20221101004651.png]]



##### 生成三地址码的递归程序示意

使用 `newTemp()` 来生成临时变量的 `strval` 属性，这样就不需要手工分配临时变量名。

`emit()` 的顺序，就是三地址码的顺序，就是编译得到程序的运行顺序。

加法：

![[不活跃主题/编译原理/中间代码生成/_attachments/Pasted image 20221101004656.png]]



##### 下标运算的一个例子

引入了数组相关的辅助运算符号：

- `elem_size(a)` ：计算数组 `a[]` 的一个元素的大小
- `&a` ：获得变量 `a` 的地址

![[不活跃主题/编译原理/中间代码生成/_attachments/Pasted image 20221101004702.png]]

##### 条件跳转

引入以下指令：

```cpp
/* 产生标号 */
label L1;

/* 测试为假，则跳转到标号 */
if-false t1 goto L1;

/* 无条件跳转到标号 */
goto L2;
```

`if`的情形：

抽象语法树：

![[不活跃主题/编译原理/中间代码生成/_attachments/Pasted image 20221101004709.png]]

三地址码的情形：

![[不活跃主题/编译原理/中间代码生成/_attachments/Pasted image 20221101004717.png]]

它的递归程序：

使用 `genLable()` 来生成一个在一定范围内有效的 `lable`；

![[不活跃主题/编译原理/中间代码生成/_attachments/Pasted image 20221101004722.png]]



##### `break`的实现思路：

可以扩展`genCode(SynaxNode* node)`函数为`genCode(SyntaxNode* node, string label)`。在`while`或者`for`中，生成一个`label`，并且把这个`label`传递给`stmt`：`genCode(stmt, label)`。这样，`stmt`中遇到`break`时，就可以使用这个`label`：`emit("goto" + label)`。



##### 函数调用的中间代码

函数调用时，首先准备参数，然后调用函数

